// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: LoggingModule.proto

#ifndef PROTOBUF_LoggingModule_2eproto__INCLUDED
#define PROTOBUF_LoggingModule_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace LoggingModule_Proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_LoggingModule_2eproto();
void protobuf_AssignDesc_LoggingModule_2eproto();
void protobuf_ShutdownFile_LoggingModule_2eproto();

class To;
class From;
class FooBar;

// ===================================================================

class To : public ::google::protobuf::Message {
 public:
  To();
  virtual ~To();

  To(const To& from);

  inline To& operator=(const To& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const To& default_instance();

  enum ToMsgCase {
    kFoo = 1,
    TOMSG_NOT_SET = 0,
  };

  void Swap(To* other);

  // implements Message ----------------------------------------------

  To* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const To& from);
  void MergeFrom(const To& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .LoggingModule_Proto.FooBar foo = 1;
  inline bool has_foo() const;
  inline void clear_foo();
  static const int kFooFieldNumber = 1;
  inline const ::LoggingModule_Proto::FooBar& foo() const;
  inline ::LoggingModule_Proto::FooBar* mutable_foo();
  inline ::LoggingModule_Proto::FooBar* release_foo();
  inline void set_allocated_foo(::LoggingModule_Proto::FooBar* foo);

  inline ToMsgCase ToMsg_case() const;
  // @@protoc_insertion_point(class_scope:LoggingModule_Proto.To)
 private:
  inline void set_has_foo();

  inline bool has_ToMsg();
  void clear_ToMsg();
  inline void clear_has_ToMsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union ToMsgUnion {
    ::LoggingModule_Proto::FooBar* foo_;
  } ToMsg_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_LoggingModule_2eproto();
  friend void protobuf_AssignDesc_LoggingModule_2eproto();
  friend void protobuf_ShutdownFile_LoggingModule_2eproto();

  void InitAsDefaultInstance();
  static To* default_instance_;
};
// -------------------------------------------------------------------

class From : public ::google::protobuf::Message {
 public:
  From();
  virtual ~From();

  From(const From& from);

  inline From& operator=(const From& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const From& default_instance();

  enum FromMsgCase {
    kBar = 1,
    FROMMSG_NOT_SET = 0,
  };

  void Swap(From* other);

  // implements Message ----------------------------------------------

  From* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const From& from);
  void MergeFrom(const From& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .LoggingModule_Proto.FooBar bar = 1;
  inline bool has_bar() const;
  inline void clear_bar();
  static const int kBarFieldNumber = 1;
  inline const ::LoggingModule_Proto::FooBar& bar() const;
  inline ::LoggingModule_Proto::FooBar* mutable_bar();
  inline ::LoggingModule_Proto::FooBar* release_bar();
  inline void set_allocated_bar(::LoggingModule_Proto::FooBar* bar);

  inline FromMsgCase FromMsg_case() const;
  // @@protoc_insertion_point(class_scope:LoggingModule_Proto.From)
 private:
  inline void set_has_bar();

  inline bool has_FromMsg();
  void clear_FromMsg();
  inline void clear_has_FromMsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union FromMsgUnion {
    ::LoggingModule_Proto::FooBar* bar_;
  } FromMsg_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_LoggingModule_2eproto();
  friend void protobuf_AssignDesc_LoggingModule_2eproto();
  friend void protobuf_ShutdownFile_LoggingModule_2eproto();

  void InitAsDefaultInstance();
  static From* default_instance_;
};
// -------------------------------------------------------------------

class FooBar : public ::google::protobuf::Message {
 public:
  FooBar();
  virtual ~FooBar();

  FooBar(const FooBar& from);

  inline FooBar& operator=(const FooBar& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FooBar& default_instance();

  void Swap(FooBar* other);

  // implements Message ----------------------------------------------

  FooBar* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FooBar& from);
  void MergeFrom(const FooBar& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:LoggingModule_Proto.FooBar)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_LoggingModule_2eproto();
  friend void protobuf_AssignDesc_LoggingModule_2eproto();
  friend void protobuf_ShutdownFile_LoggingModule_2eproto();

  void InitAsDefaultInstance();
  static FooBar* default_instance_;
};
// ===================================================================


// ===================================================================

// To

// optional .LoggingModule_Proto.FooBar foo = 1;
inline bool To::has_foo() const {
  return ToMsg_case() == kFoo;
}
inline void To::set_has_foo() {
  _oneof_case_[0] = kFoo;
}
inline void To::clear_foo() {
  if (has_foo()) {
    delete ToMsg_.foo_;
    clear_has_ToMsg();
  }
}
inline const ::LoggingModule_Proto::FooBar& To::foo() const {
  return has_foo() ? *ToMsg_.foo_
                      : ::LoggingModule_Proto::FooBar::default_instance();
}
inline ::LoggingModule_Proto::FooBar* To::mutable_foo() {
  if (!has_foo()) {
    clear_ToMsg();
    set_has_foo();
    ToMsg_.foo_ = new ::LoggingModule_Proto::FooBar;
  }
  return ToMsg_.foo_;
}
inline ::LoggingModule_Proto::FooBar* To::release_foo() {
  if (has_foo()) {
    clear_has_ToMsg();
    ::LoggingModule_Proto::FooBar* temp = ToMsg_.foo_;
    ToMsg_.foo_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void To::set_allocated_foo(::LoggingModule_Proto::FooBar* foo) {
  clear_ToMsg();
  if (foo) {
    set_has_foo();
    ToMsg_.foo_ = foo;
  }
}

inline bool To::has_ToMsg() {
  return ToMsg_case() != TOMSG_NOT_SET;
}
inline void To::clear_has_ToMsg() {
  _oneof_case_[0] = TOMSG_NOT_SET;
}
inline To::ToMsgCase To::ToMsg_case() const {
  return To::ToMsgCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// From

// optional .LoggingModule_Proto.FooBar bar = 1;
inline bool From::has_bar() const {
  return FromMsg_case() == kBar;
}
inline void From::set_has_bar() {
  _oneof_case_[0] = kBar;
}
inline void From::clear_bar() {
  if (has_bar()) {
    delete FromMsg_.bar_;
    clear_has_FromMsg();
  }
}
inline const ::LoggingModule_Proto::FooBar& From::bar() const {
  return has_bar() ? *FromMsg_.bar_
                      : ::LoggingModule_Proto::FooBar::default_instance();
}
inline ::LoggingModule_Proto::FooBar* From::mutable_bar() {
  if (!has_bar()) {
    clear_FromMsg();
    set_has_bar();
    FromMsg_.bar_ = new ::LoggingModule_Proto::FooBar;
  }
  return FromMsg_.bar_;
}
inline ::LoggingModule_Proto::FooBar* From::release_bar() {
  if (has_bar()) {
    clear_has_FromMsg();
    ::LoggingModule_Proto::FooBar* temp = FromMsg_.bar_;
    FromMsg_.bar_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void From::set_allocated_bar(::LoggingModule_Proto::FooBar* bar) {
  clear_FromMsg();
  if (bar) {
    set_has_bar();
    FromMsg_.bar_ = bar;
  }
}

inline bool From::has_FromMsg() {
  return FromMsg_case() != FROMMSG_NOT_SET;
}
inline void From::clear_has_FromMsg() {
  _oneof_case_[0] = FROMMSG_NOT_SET;
}
inline From::FromMsgCase From::FromMsg_case() const {
  return From::FromMsgCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FooBar


// @@protoc_insertion_point(namespace_scope)

}  // namespace LoggingModule_Proto

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_LoggingModule_2eproto__INCLUDED
