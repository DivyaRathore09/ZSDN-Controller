// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TopologyModule.proto

#ifndef PROTOBUF_TopologyModule_2eproto__INCLUDED
#define PROTOBUF_TopologyModule_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "CommonTopology.pb.h"
// @@protoc_insertion_point(includes)

namespace TopologyModule_Proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_TopologyModule_2eproto();
void protobuf_AssignDesc_TopologyModule_2eproto();
void protobuf_ShutdownFile_TopologyModule_2eproto();

class From;
class From_TopologyChangedEvent;
class Request;
class Request_GetTopologyRequest;
class Reply;
class Reply_GetTopologyReply;

// ===================================================================

class From_TopologyChangedEvent : public ::google::protobuf::Message {
 public:
  From_TopologyChangedEvent();
  virtual ~From_TopologyChangedEvent();

  From_TopologyChangedEvent(const From_TopologyChangedEvent& from);

  inline From_TopologyChangedEvent& operator=(const From_TopologyChangedEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const From_TopologyChangedEvent& default_instance();

  void Swap(From_TopologyChangedEvent* other);

  // implements Message ----------------------------------------------

  From_TopologyChangedEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const From_TopologyChangedEvent& from);
  void MergeFrom(const From_TopologyChangedEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.topology.Topology topology = 1;
  inline bool has_topology() const;
  inline void clear_topology();
  static const int kTopologyFieldNumber = 1;
  inline const ::common::topology::Topology& topology() const;
  inline ::common::topology::Topology* mutable_topology();
  inline ::common::topology::Topology* release_topology();
  inline void set_allocated_topology(::common::topology::Topology* topology);

  // @@protoc_insertion_point(class_scope:TopologyModule_Proto.From.TopologyChangedEvent)
 private:
  inline void set_has_topology();
  inline void clear_has_topology();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::common::topology::Topology* topology_;
  friend void  protobuf_AddDesc_TopologyModule_2eproto();
  friend void protobuf_AssignDesc_TopologyModule_2eproto();
  friend void protobuf_ShutdownFile_TopologyModule_2eproto();

  void InitAsDefaultInstance();
  static From_TopologyChangedEvent* default_instance_;
};
// -------------------------------------------------------------------

class From : public ::google::protobuf::Message {
 public:
  From();
  virtual ~From();

  From(const From& from);

  inline From& operator=(const From& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const From& default_instance();

  enum FromMsgCase {
    kTopologyChangedEvent = 1,
    FROMMSG_NOT_SET = 0,
  };

  void Swap(From* other);

  // implements Message ----------------------------------------------

  From* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const From& from);
  void MergeFrom(const From& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef From_TopologyChangedEvent TopologyChangedEvent;

  // accessors -------------------------------------------------------

  // optional .TopologyModule_Proto.From.TopologyChangedEvent topology_changed_event = 1;
  inline bool has_topology_changed_event() const;
  inline void clear_topology_changed_event();
  static const int kTopologyChangedEventFieldNumber = 1;
  inline const ::TopologyModule_Proto::From_TopologyChangedEvent& topology_changed_event() const;
  inline ::TopologyModule_Proto::From_TopologyChangedEvent* mutable_topology_changed_event();
  inline ::TopologyModule_Proto::From_TopologyChangedEvent* release_topology_changed_event();
  inline void set_allocated_topology_changed_event(::TopologyModule_Proto::From_TopologyChangedEvent* topology_changed_event);

  inline FromMsgCase FromMsg_case() const;
  // @@protoc_insertion_point(class_scope:TopologyModule_Proto.From)
 private:
  inline void set_has_topology_changed_event();

  inline bool has_FromMsg();
  void clear_FromMsg();
  inline void clear_has_FromMsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union FromMsgUnion {
    ::TopologyModule_Proto::From_TopologyChangedEvent* topology_changed_event_;
  } FromMsg_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_TopologyModule_2eproto();
  friend void protobuf_AssignDesc_TopologyModule_2eproto();
  friend void protobuf_ShutdownFile_TopologyModule_2eproto();

  void InitAsDefaultInstance();
  static From* default_instance_;
};
// -------------------------------------------------------------------

class Request_GetTopologyRequest : public ::google::protobuf::Message {
 public:
  Request_GetTopologyRequest();
  virtual ~Request_GetTopologyRequest();

  Request_GetTopologyRequest(const Request_GetTopologyRequest& from);

  inline Request_GetTopologyRequest& operator=(const Request_GetTopologyRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_GetTopologyRequest& default_instance();

  void Swap(Request_GetTopologyRequest* other);

  // implements Message ----------------------------------------------

  Request_GetTopologyRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_GetTopologyRequest& from);
  void MergeFrom(const Request_GetTopologyRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TopologyModule_Proto.Request.GetTopologyRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_TopologyModule_2eproto();
  friend void protobuf_AssignDesc_TopologyModule_2eproto();
  friend void protobuf_ShutdownFile_TopologyModule_2eproto();

  void InitAsDefaultInstance();
  static Request_GetTopologyRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  enum RequestMsgCase {
    kGetTopologyRequest = 1,
    REQUESTMSG_NOT_SET = 0,
  };

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Request_GetTopologyRequest GetTopologyRequest;

  // accessors -------------------------------------------------------

  // optional .TopologyModule_Proto.Request.GetTopologyRequest get_topology_request = 1;
  inline bool has_get_topology_request() const;
  inline void clear_get_topology_request();
  static const int kGetTopologyRequestFieldNumber = 1;
  inline const ::TopologyModule_Proto::Request_GetTopologyRequest& get_topology_request() const;
  inline ::TopologyModule_Proto::Request_GetTopologyRequest* mutable_get_topology_request();
  inline ::TopologyModule_Proto::Request_GetTopologyRequest* release_get_topology_request();
  inline void set_allocated_get_topology_request(::TopologyModule_Proto::Request_GetTopologyRequest* get_topology_request);

  inline RequestMsgCase RequestMsg_case() const;
  // @@protoc_insertion_point(class_scope:TopologyModule_Proto.Request)
 private:
  inline void set_has_get_topology_request();

  inline bool has_RequestMsg();
  void clear_RequestMsg();
  inline void clear_has_RequestMsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union RequestMsgUnion {
    ::TopologyModule_Proto::Request_GetTopologyRequest* get_topology_request_;
  } RequestMsg_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_TopologyModule_2eproto();
  friend void protobuf_AssignDesc_TopologyModule_2eproto();
  friend void protobuf_ShutdownFile_TopologyModule_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Reply_GetTopologyReply : public ::google::protobuf::Message {
 public:
  Reply_GetTopologyReply();
  virtual ~Reply_GetTopologyReply();

  Reply_GetTopologyReply(const Reply_GetTopologyReply& from);

  inline Reply_GetTopologyReply& operator=(const Reply_GetTopologyReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Reply_GetTopologyReply& default_instance();

  void Swap(Reply_GetTopologyReply* other);

  // implements Message ----------------------------------------------

  Reply_GetTopologyReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Reply_GetTopologyReply& from);
  void MergeFrom(const Reply_GetTopologyReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.topology.Topology topology = 1;
  inline bool has_topology() const;
  inline void clear_topology();
  static const int kTopologyFieldNumber = 1;
  inline const ::common::topology::Topology& topology() const;
  inline ::common::topology::Topology* mutable_topology();
  inline ::common::topology::Topology* release_topology();
  inline void set_allocated_topology(::common::topology::Topology* topology);

  // @@protoc_insertion_point(class_scope:TopologyModule_Proto.Reply.GetTopologyReply)
 private:
  inline void set_has_topology();
  inline void clear_has_topology();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::common::topology::Topology* topology_;
  friend void  protobuf_AddDesc_TopologyModule_2eproto();
  friend void protobuf_AssignDesc_TopologyModule_2eproto();
  friend void protobuf_ShutdownFile_TopologyModule_2eproto();

  void InitAsDefaultInstance();
  static Reply_GetTopologyReply* default_instance_;
};
// -------------------------------------------------------------------

class Reply : public ::google::protobuf::Message {
 public:
  Reply();
  virtual ~Reply();

  Reply(const Reply& from);

  inline Reply& operator=(const Reply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Reply& default_instance();

  enum ReplyMsgCase {
    kGetTopologyReply = 1,
    REPLYMSG_NOT_SET = 0,
  };

  void Swap(Reply* other);

  // implements Message ----------------------------------------------

  Reply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Reply& from);
  void MergeFrom(const Reply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Reply_GetTopologyReply GetTopologyReply;

  // accessors -------------------------------------------------------

  // optional .TopologyModule_Proto.Reply.GetTopologyReply get_topology_reply = 1;
  inline bool has_get_topology_reply() const;
  inline void clear_get_topology_reply();
  static const int kGetTopologyReplyFieldNumber = 1;
  inline const ::TopologyModule_Proto::Reply_GetTopologyReply& get_topology_reply() const;
  inline ::TopologyModule_Proto::Reply_GetTopologyReply* mutable_get_topology_reply();
  inline ::TopologyModule_Proto::Reply_GetTopologyReply* release_get_topology_reply();
  inline void set_allocated_get_topology_reply(::TopologyModule_Proto::Reply_GetTopologyReply* get_topology_reply);

  inline ReplyMsgCase ReplyMsg_case() const;
  // @@protoc_insertion_point(class_scope:TopologyModule_Proto.Reply)
 private:
  inline void set_has_get_topology_reply();

  inline bool has_ReplyMsg();
  void clear_ReplyMsg();
  inline void clear_has_ReplyMsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union ReplyMsgUnion {
    ::TopologyModule_Proto::Reply_GetTopologyReply* get_topology_reply_;
  } ReplyMsg_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_TopologyModule_2eproto();
  friend void protobuf_AssignDesc_TopologyModule_2eproto();
  friend void protobuf_ShutdownFile_TopologyModule_2eproto();

  void InitAsDefaultInstance();
  static Reply* default_instance_;
};
// ===================================================================


// ===================================================================

// From_TopologyChangedEvent

// required .common.topology.Topology topology = 1;
inline bool From_TopologyChangedEvent::has_topology() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void From_TopologyChangedEvent::set_has_topology() {
  _has_bits_[0] |= 0x00000001u;
}
inline void From_TopologyChangedEvent::clear_has_topology() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void From_TopologyChangedEvent::clear_topology() {
  if (topology_ != NULL) topology_->::common::topology::Topology::Clear();
  clear_has_topology();
}
inline const ::common::topology::Topology& From_TopologyChangedEvent::topology() const {
  // @@protoc_insertion_point(field_get:TopologyModule_Proto.From.TopologyChangedEvent.topology)
  return topology_ != NULL ? *topology_ : *default_instance_->topology_;
}
inline ::common::topology::Topology* From_TopologyChangedEvent::mutable_topology() {
  set_has_topology();
  if (topology_ == NULL) topology_ = new ::common::topology::Topology;
  // @@protoc_insertion_point(field_mutable:TopologyModule_Proto.From.TopologyChangedEvent.topology)
  return topology_;
}
inline ::common::topology::Topology* From_TopologyChangedEvent::release_topology() {
  clear_has_topology();
  ::common::topology::Topology* temp = topology_;
  topology_ = NULL;
  return temp;
}
inline void From_TopologyChangedEvent::set_allocated_topology(::common::topology::Topology* topology) {
  delete topology_;
  topology_ = topology;
  if (topology) {
    set_has_topology();
  } else {
    clear_has_topology();
  }
  // @@protoc_insertion_point(field_set_allocated:TopologyModule_Proto.From.TopologyChangedEvent.topology)
}

// -------------------------------------------------------------------

// From

// optional .TopologyModule_Proto.From.TopologyChangedEvent topology_changed_event = 1;
inline bool From::has_topology_changed_event() const {
  return FromMsg_case() == kTopologyChangedEvent;
}
inline void From::set_has_topology_changed_event() {
  _oneof_case_[0] = kTopologyChangedEvent;
}
inline void From::clear_topology_changed_event() {
  if (has_topology_changed_event()) {
    delete FromMsg_.topology_changed_event_;
    clear_has_FromMsg();
  }
}
inline const ::TopologyModule_Proto::From_TopologyChangedEvent& From::topology_changed_event() const {
  return has_topology_changed_event() ? *FromMsg_.topology_changed_event_
                      : ::TopologyModule_Proto::From_TopologyChangedEvent::default_instance();
}
inline ::TopologyModule_Proto::From_TopologyChangedEvent* From::mutable_topology_changed_event() {
  if (!has_topology_changed_event()) {
    clear_FromMsg();
    set_has_topology_changed_event();
    FromMsg_.topology_changed_event_ = new ::TopologyModule_Proto::From_TopologyChangedEvent;
  }
  return FromMsg_.topology_changed_event_;
}
inline ::TopologyModule_Proto::From_TopologyChangedEvent* From::release_topology_changed_event() {
  if (has_topology_changed_event()) {
    clear_has_FromMsg();
    ::TopologyModule_Proto::From_TopologyChangedEvent* temp = FromMsg_.topology_changed_event_;
    FromMsg_.topology_changed_event_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void From::set_allocated_topology_changed_event(::TopologyModule_Proto::From_TopologyChangedEvent* topology_changed_event) {
  clear_FromMsg();
  if (topology_changed_event) {
    set_has_topology_changed_event();
    FromMsg_.topology_changed_event_ = topology_changed_event;
  }
}

inline bool From::has_FromMsg() {
  return FromMsg_case() != FROMMSG_NOT_SET;
}
inline void From::clear_has_FromMsg() {
  _oneof_case_[0] = FROMMSG_NOT_SET;
}
inline From::FromMsgCase From::FromMsg_case() const {
  return From::FromMsgCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Request_GetTopologyRequest

// -------------------------------------------------------------------

// Request

// optional .TopologyModule_Proto.Request.GetTopologyRequest get_topology_request = 1;
inline bool Request::has_get_topology_request() const {
  return RequestMsg_case() == kGetTopologyRequest;
}
inline void Request::set_has_get_topology_request() {
  _oneof_case_[0] = kGetTopologyRequest;
}
inline void Request::clear_get_topology_request() {
  if (has_get_topology_request()) {
    delete RequestMsg_.get_topology_request_;
    clear_has_RequestMsg();
  }
}
inline const ::TopologyModule_Proto::Request_GetTopologyRequest& Request::get_topology_request() const {
  return has_get_topology_request() ? *RequestMsg_.get_topology_request_
                      : ::TopologyModule_Proto::Request_GetTopologyRequest::default_instance();
}
inline ::TopologyModule_Proto::Request_GetTopologyRequest* Request::mutable_get_topology_request() {
  if (!has_get_topology_request()) {
    clear_RequestMsg();
    set_has_get_topology_request();
    RequestMsg_.get_topology_request_ = new ::TopologyModule_Proto::Request_GetTopologyRequest;
  }
  return RequestMsg_.get_topology_request_;
}
inline ::TopologyModule_Proto::Request_GetTopologyRequest* Request::release_get_topology_request() {
  if (has_get_topology_request()) {
    clear_has_RequestMsg();
    ::TopologyModule_Proto::Request_GetTopologyRequest* temp = RequestMsg_.get_topology_request_;
    RequestMsg_.get_topology_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_get_topology_request(::TopologyModule_Proto::Request_GetTopologyRequest* get_topology_request) {
  clear_RequestMsg();
  if (get_topology_request) {
    set_has_get_topology_request();
    RequestMsg_.get_topology_request_ = get_topology_request;
  }
}

inline bool Request::has_RequestMsg() {
  return RequestMsg_case() != REQUESTMSG_NOT_SET;
}
inline void Request::clear_has_RequestMsg() {
  _oneof_case_[0] = REQUESTMSG_NOT_SET;
}
inline Request::RequestMsgCase Request::RequestMsg_case() const {
  return Request::RequestMsgCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Reply_GetTopologyReply

// required .common.topology.Topology topology = 1;
inline bool Reply_GetTopologyReply::has_topology() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Reply_GetTopologyReply::set_has_topology() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Reply_GetTopologyReply::clear_has_topology() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Reply_GetTopologyReply::clear_topology() {
  if (topology_ != NULL) topology_->::common::topology::Topology::Clear();
  clear_has_topology();
}
inline const ::common::topology::Topology& Reply_GetTopologyReply::topology() const {
  // @@protoc_insertion_point(field_get:TopologyModule_Proto.Reply.GetTopologyReply.topology)
  return topology_ != NULL ? *topology_ : *default_instance_->topology_;
}
inline ::common::topology::Topology* Reply_GetTopologyReply::mutable_topology() {
  set_has_topology();
  if (topology_ == NULL) topology_ = new ::common::topology::Topology;
  // @@protoc_insertion_point(field_mutable:TopologyModule_Proto.Reply.GetTopologyReply.topology)
  return topology_;
}
inline ::common::topology::Topology* Reply_GetTopologyReply::release_topology() {
  clear_has_topology();
  ::common::topology::Topology* temp = topology_;
  topology_ = NULL;
  return temp;
}
inline void Reply_GetTopologyReply::set_allocated_topology(::common::topology::Topology* topology) {
  delete topology_;
  topology_ = topology;
  if (topology) {
    set_has_topology();
  } else {
    clear_has_topology();
  }
  // @@protoc_insertion_point(field_set_allocated:TopologyModule_Proto.Reply.GetTopologyReply.topology)
}

// -------------------------------------------------------------------

// Reply

// optional .TopologyModule_Proto.Reply.GetTopologyReply get_topology_reply = 1;
inline bool Reply::has_get_topology_reply() const {
  return ReplyMsg_case() == kGetTopologyReply;
}
inline void Reply::set_has_get_topology_reply() {
  _oneof_case_[0] = kGetTopologyReply;
}
inline void Reply::clear_get_topology_reply() {
  if (has_get_topology_reply()) {
    delete ReplyMsg_.get_topology_reply_;
    clear_has_ReplyMsg();
  }
}
inline const ::TopologyModule_Proto::Reply_GetTopologyReply& Reply::get_topology_reply() const {
  return has_get_topology_reply() ? *ReplyMsg_.get_topology_reply_
                      : ::TopologyModule_Proto::Reply_GetTopologyReply::default_instance();
}
inline ::TopologyModule_Proto::Reply_GetTopologyReply* Reply::mutable_get_topology_reply() {
  if (!has_get_topology_reply()) {
    clear_ReplyMsg();
    set_has_get_topology_reply();
    ReplyMsg_.get_topology_reply_ = new ::TopologyModule_Proto::Reply_GetTopologyReply;
  }
  return ReplyMsg_.get_topology_reply_;
}
inline ::TopologyModule_Proto::Reply_GetTopologyReply* Reply::release_get_topology_reply() {
  if (has_get_topology_reply()) {
    clear_has_ReplyMsg();
    ::TopologyModule_Proto::Reply_GetTopologyReply* temp = ReplyMsg_.get_topology_reply_;
    ReplyMsg_.get_topology_reply_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Reply::set_allocated_get_topology_reply(::TopologyModule_Proto::Reply_GetTopologyReply* get_topology_reply) {
  clear_ReplyMsg();
  if (get_topology_reply) {
    set_has_get_topology_reply();
    ReplyMsg_.get_topology_reply_ = get_topology_reply;
  }
}

inline bool Reply::has_ReplyMsg() {
  return ReplyMsg_case() != REPLYMSG_NOT_SET;
}
inline void Reply::clear_has_ReplyMsg() {
  _oneof_case_[0] = REPLYMSG_NOT_SET;
}
inline Reply::ReplyMsgCase Reply::ReplyMsg_case() const {
  return Reply::ReplyMsgCase(_oneof_case_[0]);
}

// @@protoc_insertion_point(namespace_scope)

}  // namespace TopologyModule_Proto

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_TopologyModule_2eproto__INCLUDED
