// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CommonTopology.proto

#ifndef PROTOBUF_CommonTopology_2eproto__INCLUDED
#define PROTOBUF_CommonTopology_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace common {
namespace topology {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CommonTopology_2eproto();
void protobuf_AssignDesc_CommonTopology_2eproto();
void protobuf_ShutdownFile_CommonTopology_2eproto();

class AttachmentPoint;
class PortSpecs;
class Device;
class SwitchPort;
class SwitchToSwitchLink;
class SwitchSpecs;
class Switch;
class Topology;

// ===================================================================

class AttachmentPoint : public ::google::protobuf::Message {
 public:
  AttachmentPoint();
  virtual ~AttachmentPoint();

  AttachmentPoint(const AttachmentPoint& from);

  inline AttachmentPoint& operator=(const AttachmentPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AttachmentPoint& default_instance();

  void Swap(AttachmentPoint* other);

  // implements Message ----------------------------------------------

  AttachmentPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AttachmentPoint& from);
  void MergeFrom(const AttachmentPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 switch_dpid = 1;
  inline bool has_switch_dpid() const;
  inline void clear_switch_dpid();
  static const int kSwitchDpidFieldNumber = 1;
  inline ::google::protobuf::uint64 switch_dpid() const;
  inline void set_switch_dpid(::google::protobuf::uint64 value);

  // required uint32 switch_port = 2;
  inline bool has_switch_port() const;
  inline void clear_switch_port();
  static const int kSwitchPortFieldNumber = 2;
  inline ::google::protobuf::uint32 switch_port() const;
  inline void set_switch_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:common.topology.AttachmentPoint)
 private:
  inline void set_has_switch_dpid();
  inline void clear_has_switch_dpid();
  inline void set_has_switch_port();
  inline void clear_has_switch_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 switch_dpid_;
  ::google::protobuf::uint32 switch_port_;
  friend void  protobuf_AddDesc_CommonTopology_2eproto();
  friend void protobuf_AssignDesc_CommonTopology_2eproto();
  friend void protobuf_ShutdownFile_CommonTopology_2eproto();

  void InitAsDefaultInstance();
  static AttachmentPoint* default_instance_;
};
// -------------------------------------------------------------------

class PortSpecs : public ::google::protobuf::Message {
 public:
  PortSpecs();
  virtual ~PortSpecs();

  PortSpecs(const PortSpecs& from);

  inline PortSpecs& operator=(const PortSpecs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PortSpecs& default_instance();

  void Swap(PortSpecs* other);

  // implements Message ----------------------------------------------

  PortSpecs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PortSpecs& from);
  void MergeFrom(const PortSpecs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 MAC_address = 1;
  inline bool has_mac_address() const;
  inline void clear_mac_address();
  static const int kMACAddressFieldNumber = 1;
  inline ::google::protobuf::uint64 mac_address() const;
  inline void set_mac_address(::google::protobuf::uint64 value);

  // optional string port_name = 2;
  inline bool has_port_name() const;
  inline void clear_port_name();
  static const int kPortNameFieldNumber = 2;
  inline const ::std::string& port_name() const;
  inline void set_port_name(const ::std::string& value);
  inline void set_port_name(const char* value);
  inline void set_port_name(const char* value, size_t size);
  inline ::std::string* mutable_port_name();
  inline ::std::string* release_port_name();
  inline void set_allocated_port_name(::std::string* port_name);

  // optional uint32 config = 3;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 3;
  inline ::google::protobuf::uint32 config() const;
  inline void set_config(::google::protobuf::uint32 value);

  // optional uint32 state = 4;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 4;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // optional uint32 curr = 5;
  inline bool has_curr() const;
  inline void clear_curr();
  static const int kCurrFieldNumber = 5;
  inline ::google::protobuf::uint32 curr() const;
  inline void set_curr(::google::protobuf::uint32 value);

  // optional uint32 advertised = 6;
  inline bool has_advertised() const;
  inline void clear_advertised();
  static const int kAdvertisedFieldNumber = 6;
  inline ::google::protobuf::uint32 advertised() const;
  inline void set_advertised(::google::protobuf::uint32 value);

  // optional uint32 supported = 7;
  inline bool has_supported() const;
  inline void clear_supported();
  static const int kSupportedFieldNumber = 7;
  inline ::google::protobuf::uint32 supported() const;
  inline void set_supported(::google::protobuf::uint32 value);

  // optional uint32 peer = 8;
  inline bool has_peer() const;
  inline void clear_peer();
  static const int kPeerFieldNumber = 8;
  inline ::google::protobuf::uint32 peer() const;
  inline void set_peer(::google::protobuf::uint32 value);

  // optional uint32 curr_speed = 9;
  inline bool has_curr_speed() const;
  inline void clear_curr_speed();
  static const int kCurrSpeedFieldNumber = 9;
  inline ::google::protobuf::uint32 curr_speed() const;
  inline void set_curr_speed(::google::protobuf::uint32 value);

  // optional uint32 max_speed = 10;
  inline bool has_max_speed() const;
  inline void clear_max_speed();
  static const int kMaxSpeedFieldNumber = 10;
  inline ::google::protobuf::uint32 max_speed() const;
  inline void set_max_speed(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:common.topology.PortSpecs)
 private:
  inline void set_has_mac_address();
  inline void clear_has_mac_address();
  inline void set_has_port_name();
  inline void clear_has_port_name();
  inline void set_has_config();
  inline void clear_has_config();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_curr();
  inline void clear_has_curr();
  inline void set_has_advertised();
  inline void clear_has_advertised();
  inline void set_has_supported();
  inline void clear_has_supported();
  inline void set_has_peer();
  inline void clear_has_peer();
  inline void set_has_curr_speed();
  inline void clear_has_curr_speed();
  inline void set_has_max_speed();
  inline void clear_has_max_speed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 mac_address_;
  ::std::string* port_name_;
  ::google::protobuf::uint32 config_;
  ::google::protobuf::uint32 state_;
  ::google::protobuf::uint32 curr_;
  ::google::protobuf::uint32 advertised_;
  ::google::protobuf::uint32 supported_;
  ::google::protobuf::uint32 peer_;
  ::google::protobuf::uint32 curr_speed_;
  ::google::protobuf::uint32 max_speed_;
  friend void  protobuf_AddDesc_CommonTopology_2eproto();
  friend void protobuf_AssignDesc_CommonTopology_2eproto();
  friend void protobuf_ShutdownFile_CommonTopology_2eproto();

  void InitAsDefaultInstance();
  static PortSpecs* default_instance_;
};
// -------------------------------------------------------------------

class Device : public ::google::protobuf::Message {
 public:
  Device();
  virtual ~Device();

  Device(const Device& from);

  inline Device& operator=(const Device& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Device& default_instance();

  void Swap(Device* other);

  // implements Message ----------------------------------------------

  Device* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Device& from);
  void MergeFrom(const Device& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 MAC_address = 1;
  inline bool has_mac_address() const;
  inline void clear_mac_address();
  static const int kMACAddressFieldNumber = 1;
  inline ::google::protobuf::uint64 mac_address() const;
  inline void set_mac_address(::google::protobuf::uint64 value);

  // repeated uint32 IPv4_address = 2;
  inline int ipv4_address_size() const;
  inline void clear_ipv4_address();
  static const int kIPv4AddressFieldNumber = 2;
  inline ::google::protobuf::uint32 ipv4_address(int index) const;
  inline void set_ipv4_address(int index, ::google::protobuf::uint32 value);
  inline void add_ipv4_address(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      ipv4_address() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_ipv4_address();

  // repeated bytes IPv6_address = 3;
  inline int ipv6_address_size() const;
  inline void clear_ipv6_address();
  static const int kIPv6AddressFieldNumber = 3;
  inline const ::std::string& ipv6_address(int index) const;
  inline ::std::string* mutable_ipv6_address(int index);
  inline void set_ipv6_address(int index, const ::std::string& value);
  inline void set_ipv6_address(int index, const char* value);
  inline void set_ipv6_address(int index, const void* value, size_t size);
  inline ::std::string* add_ipv6_address();
  inline void add_ipv6_address(const ::std::string& value);
  inline void add_ipv6_address(const char* value);
  inline void add_ipv6_address(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& ipv6_address() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ipv6_address();

  // optional uint32 vlan = 4;
  inline bool has_vlan() const;
  inline void clear_vlan();
  static const int kVlanFieldNumber = 4;
  inline ::google::protobuf::uint32 vlan() const;
  inline void set_vlan(::google::protobuf::uint32 value);

  // required uint64 millis_since_last_seen = 5;
  inline bool has_millis_since_last_seen() const;
  inline void clear_millis_since_last_seen();
  static const int kMillisSinceLastSeenFieldNumber = 5;
  inline ::google::protobuf::uint64 millis_since_last_seen() const;
  inline void set_millis_since_last_seen(::google::protobuf::uint64 value);

  // required .common.topology.AttachmentPoint attachment_point = 6;
  inline bool has_attachment_point() const;
  inline void clear_attachment_point();
  static const int kAttachmentPointFieldNumber = 6;
  inline const ::common::topology::AttachmentPoint& attachment_point() const;
  inline ::common::topology::AttachmentPoint* mutable_attachment_point();
  inline ::common::topology::AttachmentPoint* release_attachment_point();
  inline void set_allocated_attachment_point(::common::topology::AttachmentPoint* attachment_point);

  // repeated .common.topology.AttachmentPoint additional_attachment_points = 7;
  inline int additional_attachment_points_size() const;
  inline void clear_additional_attachment_points();
  static const int kAdditionalAttachmentPointsFieldNumber = 7;
  inline const ::common::topology::AttachmentPoint& additional_attachment_points(int index) const;
  inline ::common::topology::AttachmentPoint* mutable_additional_attachment_points(int index);
  inline ::common::topology::AttachmentPoint* add_additional_attachment_points();
  inline const ::google::protobuf::RepeatedPtrField< ::common::topology::AttachmentPoint >&
      additional_attachment_points() const;
  inline ::google::protobuf::RepeatedPtrField< ::common::topology::AttachmentPoint >*
      mutable_additional_attachment_points();

  // @@protoc_insertion_point(class_scope:common.topology.Device)
 private:
  inline void set_has_mac_address();
  inline void clear_has_mac_address();
  inline void set_has_vlan();
  inline void clear_has_vlan();
  inline void set_has_millis_since_last_seen();
  inline void clear_has_millis_since_last_seen();
  inline void set_has_attachment_point();
  inline void clear_has_attachment_point();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 mac_address_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ipv4_address_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ipv6_address_;
  ::google::protobuf::uint64 millis_since_last_seen_;
  ::common::topology::AttachmentPoint* attachment_point_;
  ::google::protobuf::RepeatedPtrField< ::common::topology::AttachmentPoint > additional_attachment_points_;
  ::google::protobuf::uint32 vlan_;
  friend void  protobuf_AddDesc_CommonTopology_2eproto();
  friend void protobuf_AssignDesc_CommonTopology_2eproto();
  friend void protobuf_ShutdownFile_CommonTopology_2eproto();

  void InitAsDefaultInstance();
  static Device* default_instance_;
};
// -------------------------------------------------------------------

class SwitchPort : public ::google::protobuf::Message {
 public:
  SwitchPort();
  virtual ~SwitchPort();

  SwitchPort(const SwitchPort& from);

  inline SwitchPort& operator=(const SwitchPort& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SwitchPort& default_instance();

  void Swap(SwitchPort* other);

  // implements Message ----------------------------------------------

  SwitchPort* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SwitchPort& from);
  void MergeFrom(const SwitchPort& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.topology.AttachmentPoint attachment_point = 1;
  inline bool has_attachment_point() const;
  inline void clear_attachment_point();
  static const int kAttachmentPointFieldNumber = 1;
  inline const ::common::topology::AttachmentPoint& attachment_point() const;
  inline ::common::topology::AttachmentPoint* mutable_attachment_point();
  inline ::common::topology::AttachmentPoint* release_attachment_point();
  inline void set_allocated_attachment_point(::common::topology::AttachmentPoint* attachment_point);

  // optional .common.topology.PortSpecs port_specs = 2;
  inline bool has_port_specs() const;
  inline void clear_port_specs();
  static const int kPortSpecsFieldNumber = 2;
  inline const ::common::topology::PortSpecs& port_specs() const;
  inline ::common::topology::PortSpecs* mutable_port_specs();
  inline ::common::topology::PortSpecs* release_port_specs();
  inline void set_allocated_port_specs(::common::topology::PortSpecs* port_specs);

  // @@protoc_insertion_point(class_scope:common.topology.SwitchPort)
 private:
  inline void set_has_attachment_point();
  inline void clear_has_attachment_point();
  inline void set_has_port_specs();
  inline void clear_has_port_specs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::common::topology::AttachmentPoint* attachment_point_;
  ::common::topology::PortSpecs* port_specs_;
  friend void  protobuf_AddDesc_CommonTopology_2eproto();
  friend void protobuf_AssignDesc_CommonTopology_2eproto();
  friend void protobuf_ShutdownFile_CommonTopology_2eproto();

  void InitAsDefaultInstance();
  static SwitchPort* default_instance_;
};
// -------------------------------------------------------------------

class SwitchToSwitchLink : public ::google::protobuf::Message {
 public:
  SwitchToSwitchLink();
  virtual ~SwitchToSwitchLink();

  SwitchToSwitchLink(const SwitchToSwitchLink& from);

  inline SwitchToSwitchLink& operator=(const SwitchToSwitchLink& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SwitchToSwitchLink& default_instance();

  void Swap(SwitchToSwitchLink* other);

  // implements Message ----------------------------------------------

  SwitchToSwitchLink* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SwitchToSwitchLink& from);
  void MergeFrom(const SwitchToSwitchLink& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.topology.AttachmentPoint source = 1;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 1;
  inline const ::common::topology::AttachmentPoint& source() const;
  inline ::common::topology::AttachmentPoint* mutable_source();
  inline ::common::topology::AttachmentPoint* release_source();
  inline void set_allocated_source(::common::topology::AttachmentPoint* source);

  // required .common.topology.AttachmentPoint target = 2;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 2;
  inline const ::common::topology::AttachmentPoint& target() const;
  inline ::common::topology::AttachmentPoint* mutable_target();
  inline ::common::topology::AttachmentPoint* release_target();
  inline void set_allocated_target(::common::topology::AttachmentPoint* target);

  // @@protoc_insertion_point(class_scope:common.topology.SwitchToSwitchLink)
 private:
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_target();
  inline void clear_has_target();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::common::topology::AttachmentPoint* source_;
  ::common::topology::AttachmentPoint* target_;
  friend void  protobuf_AddDesc_CommonTopology_2eproto();
  friend void protobuf_AssignDesc_CommonTopology_2eproto();
  friend void protobuf_ShutdownFile_CommonTopology_2eproto();

  void InitAsDefaultInstance();
  static SwitchToSwitchLink* default_instance_;
};
// -------------------------------------------------------------------

class SwitchSpecs : public ::google::protobuf::Message {
 public:
  SwitchSpecs();
  virtual ~SwitchSpecs();

  SwitchSpecs(const SwitchSpecs& from);

  inline SwitchSpecs& operator=(const SwitchSpecs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SwitchSpecs& default_instance();

  void Swap(SwitchSpecs* other);

  // implements Message ----------------------------------------------

  SwitchSpecs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SwitchSpecs& from);
  void MergeFrom(const SwitchSpecs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 n_buffers = 1;
  inline bool has_n_buffers() const;
  inline void clear_n_buffers();
  static const int kNBuffersFieldNumber = 1;
  inline ::google::protobuf::uint32 n_buffers() const;
  inline void set_n_buffers(::google::protobuf::uint32 value);

  // optional uint32 n_tables = 2;
  inline bool has_n_tables() const;
  inline void clear_n_tables();
  static const int kNTablesFieldNumber = 2;
  inline ::google::protobuf::uint32 n_tables() const;
  inline void set_n_tables(::google::protobuf::uint32 value);

  // optional uint32 auxiliary_id = 3;
  inline bool has_auxiliary_id() const;
  inline void clear_auxiliary_id();
  static const int kAuxiliaryIdFieldNumber = 3;
  inline ::google::protobuf::uint32 auxiliary_id() const;
  inline void set_auxiliary_id(::google::protobuf::uint32 value);

  // optional uint32 capabilities = 4;
  inline bool has_capabilities() const;
  inline void clear_capabilities();
  static const int kCapabilitiesFieldNumber = 4;
  inline ::google::protobuf::uint32 capabilities() const;
  inline void set_capabilities(::google::protobuf::uint32 value);

  // optional uint32 reserved = 5;
  inline bool has_reserved() const;
  inline void clear_reserved();
  static const int kReservedFieldNumber = 5;
  inline ::google::protobuf::uint32 reserved() const;
  inline void set_reserved(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:common.topology.SwitchSpecs)
 private:
  inline void set_has_n_buffers();
  inline void clear_has_n_buffers();
  inline void set_has_n_tables();
  inline void clear_has_n_tables();
  inline void set_has_auxiliary_id();
  inline void clear_has_auxiliary_id();
  inline void set_has_capabilities();
  inline void clear_has_capabilities();
  inline void set_has_reserved();
  inline void clear_has_reserved();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 n_buffers_;
  ::google::protobuf::uint32 n_tables_;
  ::google::protobuf::uint32 auxiliary_id_;
  ::google::protobuf::uint32 capabilities_;
  ::google::protobuf::uint32 reserved_;
  friend void  protobuf_AddDesc_CommonTopology_2eproto();
  friend void protobuf_AssignDesc_CommonTopology_2eproto();
  friend void protobuf_ShutdownFile_CommonTopology_2eproto();

  void InitAsDefaultInstance();
  static SwitchSpecs* default_instance_;
};
// -------------------------------------------------------------------

class Switch : public ::google::protobuf::Message {
 public:
  Switch();
  virtual ~Switch();

  Switch(const Switch& from);

  inline Switch& operator=(const Switch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Switch& default_instance();

  void Swap(Switch* other);

  // implements Message ----------------------------------------------

  Switch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Switch& from);
  void MergeFrom(const Switch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 switch_dpid = 1;
  inline bool has_switch_dpid() const;
  inline void clear_switch_dpid();
  static const int kSwitchDpidFieldNumber = 1;
  inline ::google::protobuf::uint64 switch_dpid() const;
  inline void set_switch_dpid(::google::protobuf::uint64 value);

  // required uint32 openflow_version = 2;
  inline bool has_openflow_version() const;
  inline void clear_openflow_version();
  static const int kOpenflowVersionFieldNumber = 2;
  inline ::google::protobuf::uint32 openflow_version() const;
  inline void set_openflow_version(::google::protobuf::uint32 value);

  // repeated .common.topology.SwitchPort switch_ports = 3;
  inline int switch_ports_size() const;
  inline void clear_switch_ports();
  static const int kSwitchPortsFieldNumber = 3;
  inline const ::common::topology::SwitchPort& switch_ports(int index) const;
  inline ::common::topology::SwitchPort* mutable_switch_ports(int index);
  inline ::common::topology::SwitchPort* add_switch_ports();
  inline const ::google::protobuf::RepeatedPtrField< ::common::topology::SwitchPort >&
      switch_ports() const;
  inline ::google::protobuf::RepeatedPtrField< ::common::topology::SwitchPort >*
      mutable_switch_ports();

  // optional .common.topology.SwitchSpecs switch_specs = 4;
  inline bool has_switch_specs() const;
  inline void clear_switch_specs();
  static const int kSwitchSpecsFieldNumber = 4;
  inline const ::common::topology::SwitchSpecs& switch_specs() const;
  inline ::common::topology::SwitchSpecs* mutable_switch_specs();
  inline ::common::topology::SwitchSpecs* release_switch_specs();
  inline void set_allocated_switch_specs(::common::topology::SwitchSpecs* switch_specs);

  // @@protoc_insertion_point(class_scope:common.topology.Switch)
 private:
  inline void set_has_switch_dpid();
  inline void clear_has_switch_dpid();
  inline void set_has_openflow_version();
  inline void clear_has_openflow_version();
  inline void set_has_switch_specs();
  inline void clear_has_switch_specs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 switch_dpid_;
  ::google::protobuf::RepeatedPtrField< ::common::topology::SwitchPort > switch_ports_;
  ::common::topology::SwitchSpecs* switch_specs_;
  ::google::protobuf::uint32 openflow_version_;
  friend void  protobuf_AddDesc_CommonTopology_2eproto();
  friend void protobuf_AssignDesc_CommonTopology_2eproto();
  friend void protobuf_ShutdownFile_CommonTopology_2eproto();

  void InitAsDefaultInstance();
  static Switch* default_instance_;
};
// -------------------------------------------------------------------

class Topology : public ::google::protobuf::Message {
 public:
  Topology();
  virtual ~Topology();

  Topology(const Topology& from);

  inline Topology& operator=(const Topology& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Topology& default_instance();

  void Swap(Topology* other);

  // implements Message ----------------------------------------------

  Topology* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Topology& from);
  void MergeFrom(const Topology& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .common.topology.Switch switches = 1;
  inline int switches_size() const;
  inline void clear_switches();
  static const int kSwitchesFieldNumber = 1;
  inline const ::common::topology::Switch& switches(int index) const;
  inline ::common::topology::Switch* mutable_switches(int index);
  inline ::common::topology::Switch* add_switches();
  inline const ::google::protobuf::RepeatedPtrField< ::common::topology::Switch >&
      switches() const;
  inline ::google::protobuf::RepeatedPtrField< ::common::topology::Switch >*
      mutable_switches();

  // repeated .common.topology.SwitchToSwitchLink switch_to_switch_links = 2;
  inline int switch_to_switch_links_size() const;
  inline void clear_switch_to_switch_links();
  static const int kSwitchToSwitchLinksFieldNumber = 2;
  inline const ::common::topology::SwitchToSwitchLink& switch_to_switch_links(int index) const;
  inline ::common::topology::SwitchToSwitchLink* mutable_switch_to_switch_links(int index);
  inline ::common::topology::SwitchToSwitchLink* add_switch_to_switch_links();
  inline const ::google::protobuf::RepeatedPtrField< ::common::topology::SwitchToSwitchLink >&
      switch_to_switch_links() const;
  inline ::google::protobuf::RepeatedPtrField< ::common::topology::SwitchToSwitchLink >*
      mutable_switch_to_switch_links();

  // @@protoc_insertion_point(class_scope:common.topology.Topology)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::common::topology::Switch > switches_;
  ::google::protobuf::RepeatedPtrField< ::common::topology::SwitchToSwitchLink > switch_to_switch_links_;
  friend void  protobuf_AddDesc_CommonTopology_2eproto();
  friend void protobuf_AssignDesc_CommonTopology_2eproto();
  friend void protobuf_ShutdownFile_CommonTopology_2eproto();

  void InitAsDefaultInstance();
  static Topology* default_instance_;
};
// ===================================================================


// ===================================================================

// AttachmentPoint

// required uint64 switch_dpid = 1;
inline bool AttachmentPoint::has_switch_dpid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AttachmentPoint::set_has_switch_dpid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AttachmentPoint::clear_has_switch_dpid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AttachmentPoint::clear_switch_dpid() {
  switch_dpid_ = GOOGLE_ULONGLONG(0);
  clear_has_switch_dpid();
}
inline ::google::protobuf::uint64 AttachmentPoint::switch_dpid() const {
  // @@protoc_insertion_point(field_get:common.topology.AttachmentPoint.switch_dpid)
  return switch_dpid_;
}
inline void AttachmentPoint::set_switch_dpid(::google::protobuf::uint64 value) {
  set_has_switch_dpid();
  switch_dpid_ = value;
  // @@protoc_insertion_point(field_set:common.topology.AttachmentPoint.switch_dpid)
}

// required uint32 switch_port = 2;
inline bool AttachmentPoint::has_switch_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AttachmentPoint::set_has_switch_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AttachmentPoint::clear_has_switch_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AttachmentPoint::clear_switch_port() {
  switch_port_ = 0u;
  clear_has_switch_port();
}
inline ::google::protobuf::uint32 AttachmentPoint::switch_port() const {
  // @@protoc_insertion_point(field_get:common.topology.AttachmentPoint.switch_port)
  return switch_port_;
}
inline void AttachmentPoint::set_switch_port(::google::protobuf::uint32 value) {
  set_has_switch_port();
  switch_port_ = value;
  // @@protoc_insertion_point(field_set:common.topology.AttachmentPoint.switch_port)
}

// -------------------------------------------------------------------

// PortSpecs

// optional uint64 MAC_address = 1;
inline bool PortSpecs::has_mac_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PortSpecs::set_has_mac_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PortSpecs::clear_has_mac_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PortSpecs::clear_mac_address() {
  mac_address_ = GOOGLE_ULONGLONG(0);
  clear_has_mac_address();
}
inline ::google::protobuf::uint64 PortSpecs::mac_address() const {
  // @@protoc_insertion_point(field_get:common.topology.PortSpecs.MAC_address)
  return mac_address_;
}
inline void PortSpecs::set_mac_address(::google::protobuf::uint64 value) {
  set_has_mac_address();
  mac_address_ = value;
  // @@protoc_insertion_point(field_set:common.topology.PortSpecs.MAC_address)
}

// optional string port_name = 2;
inline bool PortSpecs::has_port_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PortSpecs::set_has_port_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PortSpecs::clear_has_port_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PortSpecs::clear_port_name() {
  if (port_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    port_name_->clear();
  }
  clear_has_port_name();
}
inline const ::std::string& PortSpecs::port_name() const {
  // @@protoc_insertion_point(field_get:common.topology.PortSpecs.port_name)
  return *port_name_;
}
inline void PortSpecs::set_port_name(const ::std::string& value) {
  set_has_port_name();
  if (port_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    port_name_ = new ::std::string;
  }
  port_name_->assign(value);
  // @@protoc_insertion_point(field_set:common.topology.PortSpecs.port_name)
}
inline void PortSpecs::set_port_name(const char* value) {
  set_has_port_name();
  if (port_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    port_name_ = new ::std::string;
  }
  port_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.topology.PortSpecs.port_name)
}
inline void PortSpecs::set_port_name(const char* value, size_t size) {
  set_has_port_name();
  if (port_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    port_name_ = new ::std::string;
  }
  port_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.topology.PortSpecs.port_name)
}
inline ::std::string* PortSpecs::mutable_port_name() {
  set_has_port_name();
  if (port_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    port_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.topology.PortSpecs.port_name)
  return port_name_;
}
inline ::std::string* PortSpecs::release_port_name() {
  clear_has_port_name();
  if (port_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = port_name_;
    port_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PortSpecs::set_allocated_port_name(::std::string* port_name) {
  if (port_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete port_name_;
  }
  if (port_name) {
    set_has_port_name();
    port_name_ = port_name;
  } else {
    clear_has_port_name();
    port_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.topology.PortSpecs.port_name)
}

// optional uint32 config = 3;
inline bool PortSpecs::has_config() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PortSpecs::set_has_config() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PortSpecs::clear_has_config() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PortSpecs::clear_config() {
  config_ = 0u;
  clear_has_config();
}
inline ::google::protobuf::uint32 PortSpecs::config() const {
  // @@protoc_insertion_point(field_get:common.topology.PortSpecs.config)
  return config_;
}
inline void PortSpecs::set_config(::google::protobuf::uint32 value) {
  set_has_config();
  config_ = value;
  // @@protoc_insertion_point(field_set:common.topology.PortSpecs.config)
}

// optional uint32 state = 4;
inline bool PortSpecs::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PortSpecs::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PortSpecs::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PortSpecs::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 PortSpecs::state() const {
  // @@protoc_insertion_point(field_get:common.topology.PortSpecs.state)
  return state_;
}
inline void PortSpecs::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:common.topology.PortSpecs.state)
}

// optional uint32 curr = 5;
inline bool PortSpecs::has_curr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PortSpecs::set_has_curr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PortSpecs::clear_has_curr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PortSpecs::clear_curr() {
  curr_ = 0u;
  clear_has_curr();
}
inline ::google::protobuf::uint32 PortSpecs::curr() const {
  // @@protoc_insertion_point(field_get:common.topology.PortSpecs.curr)
  return curr_;
}
inline void PortSpecs::set_curr(::google::protobuf::uint32 value) {
  set_has_curr();
  curr_ = value;
  // @@protoc_insertion_point(field_set:common.topology.PortSpecs.curr)
}

// optional uint32 advertised = 6;
inline bool PortSpecs::has_advertised() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PortSpecs::set_has_advertised() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PortSpecs::clear_has_advertised() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PortSpecs::clear_advertised() {
  advertised_ = 0u;
  clear_has_advertised();
}
inline ::google::protobuf::uint32 PortSpecs::advertised() const {
  // @@protoc_insertion_point(field_get:common.topology.PortSpecs.advertised)
  return advertised_;
}
inline void PortSpecs::set_advertised(::google::protobuf::uint32 value) {
  set_has_advertised();
  advertised_ = value;
  // @@protoc_insertion_point(field_set:common.topology.PortSpecs.advertised)
}

// optional uint32 supported = 7;
inline bool PortSpecs::has_supported() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PortSpecs::set_has_supported() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PortSpecs::clear_has_supported() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PortSpecs::clear_supported() {
  supported_ = 0u;
  clear_has_supported();
}
inline ::google::protobuf::uint32 PortSpecs::supported() const {
  // @@protoc_insertion_point(field_get:common.topology.PortSpecs.supported)
  return supported_;
}
inline void PortSpecs::set_supported(::google::protobuf::uint32 value) {
  set_has_supported();
  supported_ = value;
  // @@protoc_insertion_point(field_set:common.topology.PortSpecs.supported)
}

// optional uint32 peer = 8;
inline bool PortSpecs::has_peer() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PortSpecs::set_has_peer() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PortSpecs::clear_has_peer() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PortSpecs::clear_peer() {
  peer_ = 0u;
  clear_has_peer();
}
inline ::google::protobuf::uint32 PortSpecs::peer() const {
  // @@protoc_insertion_point(field_get:common.topology.PortSpecs.peer)
  return peer_;
}
inline void PortSpecs::set_peer(::google::protobuf::uint32 value) {
  set_has_peer();
  peer_ = value;
  // @@protoc_insertion_point(field_set:common.topology.PortSpecs.peer)
}

// optional uint32 curr_speed = 9;
inline bool PortSpecs::has_curr_speed() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PortSpecs::set_has_curr_speed() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PortSpecs::clear_has_curr_speed() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PortSpecs::clear_curr_speed() {
  curr_speed_ = 0u;
  clear_has_curr_speed();
}
inline ::google::protobuf::uint32 PortSpecs::curr_speed() const {
  // @@protoc_insertion_point(field_get:common.topology.PortSpecs.curr_speed)
  return curr_speed_;
}
inline void PortSpecs::set_curr_speed(::google::protobuf::uint32 value) {
  set_has_curr_speed();
  curr_speed_ = value;
  // @@protoc_insertion_point(field_set:common.topology.PortSpecs.curr_speed)
}

// optional uint32 max_speed = 10;
inline bool PortSpecs::has_max_speed() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PortSpecs::set_has_max_speed() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PortSpecs::clear_has_max_speed() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PortSpecs::clear_max_speed() {
  max_speed_ = 0u;
  clear_has_max_speed();
}
inline ::google::protobuf::uint32 PortSpecs::max_speed() const {
  // @@protoc_insertion_point(field_get:common.topology.PortSpecs.max_speed)
  return max_speed_;
}
inline void PortSpecs::set_max_speed(::google::protobuf::uint32 value) {
  set_has_max_speed();
  max_speed_ = value;
  // @@protoc_insertion_point(field_set:common.topology.PortSpecs.max_speed)
}

// -------------------------------------------------------------------

// Device

// required uint64 MAC_address = 1;
inline bool Device::has_mac_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Device::set_has_mac_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Device::clear_has_mac_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Device::clear_mac_address() {
  mac_address_ = GOOGLE_ULONGLONG(0);
  clear_has_mac_address();
}
inline ::google::protobuf::uint64 Device::mac_address() const {
  // @@protoc_insertion_point(field_get:common.topology.Device.MAC_address)
  return mac_address_;
}
inline void Device::set_mac_address(::google::protobuf::uint64 value) {
  set_has_mac_address();
  mac_address_ = value;
  // @@protoc_insertion_point(field_set:common.topology.Device.MAC_address)
}

// repeated uint32 IPv4_address = 2;
inline int Device::ipv4_address_size() const {
  return ipv4_address_.size();
}
inline void Device::clear_ipv4_address() {
  ipv4_address_.Clear();
}
inline ::google::protobuf::uint32 Device::ipv4_address(int index) const {
  // @@protoc_insertion_point(field_get:common.topology.Device.IPv4_address)
  return ipv4_address_.Get(index);
}
inline void Device::set_ipv4_address(int index, ::google::protobuf::uint32 value) {
  ipv4_address_.Set(index, value);
  // @@protoc_insertion_point(field_set:common.topology.Device.IPv4_address)
}
inline void Device::add_ipv4_address(::google::protobuf::uint32 value) {
  ipv4_address_.Add(value);
  // @@protoc_insertion_point(field_add:common.topology.Device.IPv4_address)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Device::ipv4_address() const {
  // @@protoc_insertion_point(field_list:common.topology.Device.IPv4_address)
  return ipv4_address_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Device::mutable_ipv4_address() {
  // @@protoc_insertion_point(field_mutable_list:common.topology.Device.IPv4_address)
  return &ipv4_address_;
}

// repeated bytes IPv6_address = 3;
inline int Device::ipv6_address_size() const {
  return ipv6_address_.size();
}
inline void Device::clear_ipv6_address() {
  ipv6_address_.Clear();
}
inline const ::std::string& Device::ipv6_address(int index) const {
  // @@protoc_insertion_point(field_get:common.topology.Device.IPv6_address)
  return ipv6_address_.Get(index);
}
inline ::std::string* Device::mutable_ipv6_address(int index) {
  // @@protoc_insertion_point(field_mutable:common.topology.Device.IPv6_address)
  return ipv6_address_.Mutable(index);
}
inline void Device::set_ipv6_address(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:common.topology.Device.IPv6_address)
  ipv6_address_.Mutable(index)->assign(value);
}
inline void Device::set_ipv6_address(int index, const char* value) {
  ipv6_address_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:common.topology.Device.IPv6_address)
}
inline void Device::set_ipv6_address(int index, const void* value, size_t size) {
  ipv6_address_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.topology.Device.IPv6_address)
}
inline ::std::string* Device::add_ipv6_address() {
  return ipv6_address_.Add();
}
inline void Device::add_ipv6_address(const ::std::string& value) {
  ipv6_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:common.topology.Device.IPv6_address)
}
inline void Device::add_ipv6_address(const char* value) {
  ipv6_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:common.topology.Device.IPv6_address)
}
inline void Device::add_ipv6_address(const void* value, size_t size) {
  ipv6_address_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:common.topology.Device.IPv6_address)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Device::ipv6_address() const {
  // @@protoc_insertion_point(field_list:common.topology.Device.IPv6_address)
  return ipv6_address_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Device::mutable_ipv6_address() {
  // @@protoc_insertion_point(field_mutable_list:common.topology.Device.IPv6_address)
  return &ipv6_address_;
}

// optional uint32 vlan = 4;
inline bool Device::has_vlan() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Device::set_has_vlan() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Device::clear_has_vlan() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Device::clear_vlan() {
  vlan_ = 0u;
  clear_has_vlan();
}
inline ::google::protobuf::uint32 Device::vlan() const {
  // @@protoc_insertion_point(field_get:common.topology.Device.vlan)
  return vlan_;
}
inline void Device::set_vlan(::google::protobuf::uint32 value) {
  set_has_vlan();
  vlan_ = value;
  // @@protoc_insertion_point(field_set:common.topology.Device.vlan)
}

// required uint64 millis_since_last_seen = 5;
inline bool Device::has_millis_since_last_seen() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Device::set_has_millis_since_last_seen() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Device::clear_has_millis_since_last_seen() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Device::clear_millis_since_last_seen() {
  millis_since_last_seen_ = GOOGLE_ULONGLONG(0);
  clear_has_millis_since_last_seen();
}
inline ::google::protobuf::uint64 Device::millis_since_last_seen() const {
  // @@protoc_insertion_point(field_get:common.topology.Device.millis_since_last_seen)
  return millis_since_last_seen_;
}
inline void Device::set_millis_since_last_seen(::google::protobuf::uint64 value) {
  set_has_millis_since_last_seen();
  millis_since_last_seen_ = value;
  // @@protoc_insertion_point(field_set:common.topology.Device.millis_since_last_seen)
}

// required .common.topology.AttachmentPoint attachment_point = 6;
inline bool Device::has_attachment_point() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Device::set_has_attachment_point() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Device::clear_has_attachment_point() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Device::clear_attachment_point() {
  if (attachment_point_ != NULL) attachment_point_->::common::topology::AttachmentPoint::Clear();
  clear_has_attachment_point();
}
inline const ::common::topology::AttachmentPoint& Device::attachment_point() const {
  // @@protoc_insertion_point(field_get:common.topology.Device.attachment_point)
  return attachment_point_ != NULL ? *attachment_point_ : *default_instance_->attachment_point_;
}
inline ::common::topology::AttachmentPoint* Device::mutable_attachment_point() {
  set_has_attachment_point();
  if (attachment_point_ == NULL) attachment_point_ = new ::common::topology::AttachmentPoint;
  // @@protoc_insertion_point(field_mutable:common.topology.Device.attachment_point)
  return attachment_point_;
}
inline ::common::topology::AttachmentPoint* Device::release_attachment_point() {
  clear_has_attachment_point();
  ::common::topology::AttachmentPoint* temp = attachment_point_;
  attachment_point_ = NULL;
  return temp;
}
inline void Device::set_allocated_attachment_point(::common::topology::AttachmentPoint* attachment_point) {
  delete attachment_point_;
  attachment_point_ = attachment_point;
  if (attachment_point) {
    set_has_attachment_point();
  } else {
    clear_has_attachment_point();
  }
  // @@protoc_insertion_point(field_set_allocated:common.topology.Device.attachment_point)
}

// repeated .common.topology.AttachmentPoint additional_attachment_points = 7;
inline int Device::additional_attachment_points_size() const {
  return additional_attachment_points_.size();
}
inline void Device::clear_additional_attachment_points() {
  additional_attachment_points_.Clear();
}
inline const ::common::topology::AttachmentPoint& Device::additional_attachment_points(int index) const {
  // @@protoc_insertion_point(field_get:common.topology.Device.additional_attachment_points)
  return additional_attachment_points_.Get(index);
}
inline ::common::topology::AttachmentPoint* Device::mutable_additional_attachment_points(int index) {
  // @@protoc_insertion_point(field_mutable:common.topology.Device.additional_attachment_points)
  return additional_attachment_points_.Mutable(index);
}
inline ::common::topology::AttachmentPoint* Device::add_additional_attachment_points() {
  // @@protoc_insertion_point(field_add:common.topology.Device.additional_attachment_points)
  return additional_attachment_points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::common::topology::AttachmentPoint >&
Device::additional_attachment_points() const {
  // @@protoc_insertion_point(field_list:common.topology.Device.additional_attachment_points)
  return additional_attachment_points_;
}
inline ::google::protobuf::RepeatedPtrField< ::common::topology::AttachmentPoint >*
Device::mutable_additional_attachment_points() {
  // @@protoc_insertion_point(field_mutable_list:common.topology.Device.additional_attachment_points)
  return &additional_attachment_points_;
}

// -------------------------------------------------------------------

// SwitchPort

// required .common.topology.AttachmentPoint attachment_point = 1;
inline bool SwitchPort::has_attachment_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SwitchPort::set_has_attachment_point() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SwitchPort::clear_has_attachment_point() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SwitchPort::clear_attachment_point() {
  if (attachment_point_ != NULL) attachment_point_->::common::topology::AttachmentPoint::Clear();
  clear_has_attachment_point();
}
inline const ::common::topology::AttachmentPoint& SwitchPort::attachment_point() const {
  // @@protoc_insertion_point(field_get:common.topology.SwitchPort.attachment_point)
  return attachment_point_ != NULL ? *attachment_point_ : *default_instance_->attachment_point_;
}
inline ::common::topology::AttachmentPoint* SwitchPort::mutable_attachment_point() {
  set_has_attachment_point();
  if (attachment_point_ == NULL) attachment_point_ = new ::common::topology::AttachmentPoint;
  // @@protoc_insertion_point(field_mutable:common.topology.SwitchPort.attachment_point)
  return attachment_point_;
}
inline ::common::topology::AttachmentPoint* SwitchPort::release_attachment_point() {
  clear_has_attachment_point();
  ::common::topology::AttachmentPoint* temp = attachment_point_;
  attachment_point_ = NULL;
  return temp;
}
inline void SwitchPort::set_allocated_attachment_point(::common::topology::AttachmentPoint* attachment_point) {
  delete attachment_point_;
  attachment_point_ = attachment_point;
  if (attachment_point) {
    set_has_attachment_point();
  } else {
    clear_has_attachment_point();
  }
  // @@protoc_insertion_point(field_set_allocated:common.topology.SwitchPort.attachment_point)
}

// optional .common.topology.PortSpecs port_specs = 2;
inline bool SwitchPort::has_port_specs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SwitchPort::set_has_port_specs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SwitchPort::clear_has_port_specs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SwitchPort::clear_port_specs() {
  if (port_specs_ != NULL) port_specs_->::common::topology::PortSpecs::Clear();
  clear_has_port_specs();
}
inline const ::common::topology::PortSpecs& SwitchPort::port_specs() const {
  // @@protoc_insertion_point(field_get:common.topology.SwitchPort.port_specs)
  return port_specs_ != NULL ? *port_specs_ : *default_instance_->port_specs_;
}
inline ::common::topology::PortSpecs* SwitchPort::mutable_port_specs() {
  set_has_port_specs();
  if (port_specs_ == NULL) port_specs_ = new ::common::topology::PortSpecs;
  // @@protoc_insertion_point(field_mutable:common.topology.SwitchPort.port_specs)
  return port_specs_;
}
inline ::common::topology::PortSpecs* SwitchPort::release_port_specs() {
  clear_has_port_specs();
  ::common::topology::PortSpecs* temp = port_specs_;
  port_specs_ = NULL;
  return temp;
}
inline void SwitchPort::set_allocated_port_specs(::common::topology::PortSpecs* port_specs) {
  delete port_specs_;
  port_specs_ = port_specs;
  if (port_specs) {
    set_has_port_specs();
  } else {
    clear_has_port_specs();
  }
  // @@protoc_insertion_point(field_set_allocated:common.topology.SwitchPort.port_specs)
}

// -------------------------------------------------------------------

// SwitchToSwitchLink

// required .common.topology.AttachmentPoint source = 1;
inline bool SwitchToSwitchLink::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SwitchToSwitchLink::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SwitchToSwitchLink::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SwitchToSwitchLink::clear_source() {
  if (source_ != NULL) source_->::common::topology::AttachmentPoint::Clear();
  clear_has_source();
}
inline const ::common::topology::AttachmentPoint& SwitchToSwitchLink::source() const {
  // @@protoc_insertion_point(field_get:common.topology.SwitchToSwitchLink.source)
  return source_ != NULL ? *source_ : *default_instance_->source_;
}
inline ::common::topology::AttachmentPoint* SwitchToSwitchLink::mutable_source() {
  set_has_source();
  if (source_ == NULL) source_ = new ::common::topology::AttachmentPoint;
  // @@protoc_insertion_point(field_mutable:common.topology.SwitchToSwitchLink.source)
  return source_;
}
inline ::common::topology::AttachmentPoint* SwitchToSwitchLink::release_source() {
  clear_has_source();
  ::common::topology::AttachmentPoint* temp = source_;
  source_ = NULL;
  return temp;
}
inline void SwitchToSwitchLink::set_allocated_source(::common::topology::AttachmentPoint* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:common.topology.SwitchToSwitchLink.source)
}

// required .common.topology.AttachmentPoint target = 2;
inline bool SwitchToSwitchLink::has_target() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SwitchToSwitchLink::set_has_target() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SwitchToSwitchLink::clear_has_target() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SwitchToSwitchLink::clear_target() {
  if (target_ != NULL) target_->::common::topology::AttachmentPoint::Clear();
  clear_has_target();
}
inline const ::common::topology::AttachmentPoint& SwitchToSwitchLink::target() const {
  // @@protoc_insertion_point(field_get:common.topology.SwitchToSwitchLink.target)
  return target_ != NULL ? *target_ : *default_instance_->target_;
}
inline ::common::topology::AttachmentPoint* SwitchToSwitchLink::mutable_target() {
  set_has_target();
  if (target_ == NULL) target_ = new ::common::topology::AttachmentPoint;
  // @@protoc_insertion_point(field_mutable:common.topology.SwitchToSwitchLink.target)
  return target_;
}
inline ::common::topology::AttachmentPoint* SwitchToSwitchLink::release_target() {
  clear_has_target();
  ::common::topology::AttachmentPoint* temp = target_;
  target_ = NULL;
  return temp;
}
inline void SwitchToSwitchLink::set_allocated_target(::common::topology::AttachmentPoint* target) {
  delete target_;
  target_ = target;
  if (target) {
    set_has_target();
  } else {
    clear_has_target();
  }
  // @@protoc_insertion_point(field_set_allocated:common.topology.SwitchToSwitchLink.target)
}

// -------------------------------------------------------------------

// SwitchSpecs

// optional uint32 n_buffers = 1;
inline bool SwitchSpecs::has_n_buffers() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SwitchSpecs::set_has_n_buffers() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SwitchSpecs::clear_has_n_buffers() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SwitchSpecs::clear_n_buffers() {
  n_buffers_ = 0u;
  clear_has_n_buffers();
}
inline ::google::protobuf::uint32 SwitchSpecs::n_buffers() const {
  // @@protoc_insertion_point(field_get:common.topology.SwitchSpecs.n_buffers)
  return n_buffers_;
}
inline void SwitchSpecs::set_n_buffers(::google::protobuf::uint32 value) {
  set_has_n_buffers();
  n_buffers_ = value;
  // @@protoc_insertion_point(field_set:common.topology.SwitchSpecs.n_buffers)
}

// optional uint32 n_tables = 2;
inline bool SwitchSpecs::has_n_tables() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SwitchSpecs::set_has_n_tables() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SwitchSpecs::clear_has_n_tables() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SwitchSpecs::clear_n_tables() {
  n_tables_ = 0u;
  clear_has_n_tables();
}
inline ::google::protobuf::uint32 SwitchSpecs::n_tables() const {
  // @@protoc_insertion_point(field_get:common.topology.SwitchSpecs.n_tables)
  return n_tables_;
}
inline void SwitchSpecs::set_n_tables(::google::protobuf::uint32 value) {
  set_has_n_tables();
  n_tables_ = value;
  // @@protoc_insertion_point(field_set:common.topology.SwitchSpecs.n_tables)
}

// optional uint32 auxiliary_id = 3;
inline bool SwitchSpecs::has_auxiliary_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SwitchSpecs::set_has_auxiliary_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SwitchSpecs::clear_has_auxiliary_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SwitchSpecs::clear_auxiliary_id() {
  auxiliary_id_ = 0u;
  clear_has_auxiliary_id();
}
inline ::google::protobuf::uint32 SwitchSpecs::auxiliary_id() const {
  // @@protoc_insertion_point(field_get:common.topology.SwitchSpecs.auxiliary_id)
  return auxiliary_id_;
}
inline void SwitchSpecs::set_auxiliary_id(::google::protobuf::uint32 value) {
  set_has_auxiliary_id();
  auxiliary_id_ = value;
  // @@protoc_insertion_point(field_set:common.topology.SwitchSpecs.auxiliary_id)
}

// optional uint32 capabilities = 4;
inline bool SwitchSpecs::has_capabilities() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SwitchSpecs::set_has_capabilities() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SwitchSpecs::clear_has_capabilities() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SwitchSpecs::clear_capabilities() {
  capabilities_ = 0u;
  clear_has_capabilities();
}
inline ::google::protobuf::uint32 SwitchSpecs::capabilities() const {
  // @@protoc_insertion_point(field_get:common.topology.SwitchSpecs.capabilities)
  return capabilities_;
}
inline void SwitchSpecs::set_capabilities(::google::protobuf::uint32 value) {
  set_has_capabilities();
  capabilities_ = value;
  // @@protoc_insertion_point(field_set:common.topology.SwitchSpecs.capabilities)
}

// optional uint32 reserved = 5;
inline bool SwitchSpecs::has_reserved() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SwitchSpecs::set_has_reserved() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SwitchSpecs::clear_has_reserved() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SwitchSpecs::clear_reserved() {
  reserved_ = 0u;
  clear_has_reserved();
}
inline ::google::protobuf::uint32 SwitchSpecs::reserved() const {
  // @@protoc_insertion_point(field_get:common.topology.SwitchSpecs.reserved)
  return reserved_;
}
inline void SwitchSpecs::set_reserved(::google::protobuf::uint32 value) {
  set_has_reserved();
  reserved_ = value;
  // @@protoc_insertion_point(field_set:common.topology.SwitchSpecs.reserved)
}

// -------------------------------------------------------------------

// Switch

// required uint64 switch_dpid = 1;
inline bool Switch::has_switch_dpid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Switch::set_has_switch_dpid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Switch::clear_has_switch_dpid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Switch::clear_switch_dpid() {
  switch_dpid_ = GOOGLE_ULONGLONG(0);
  clear_has_switch_dpid();
}
inline ::google::protobuf::uint64 Switch::switch_dpid() const {
  // @@protoc_insertion_point(field_get:common.topology.Switch.switch_dpid)
  return switch_dpid_;
}
inline void Switch::set_switch_dpid(::google::protobuf::uint64 value) {
  set_has_switch_dpid();
  switch_dpid_ = value;
  // @@protoc_insertion_point(field_set:common.topology.Switch.switch_dpid)
}

// required uint32 openflow_version = 2;
inline bool Switch::has_openflow_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Switch::set_has_openflow_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Switch::clear_has_openflow_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Switch::clear_openflow_version() {
  openflow_version_ = 0u;
  clear_has_openflow_version();
}
inline ::google::protobuf::uint32 Switch::openflow_version() const {
  // @@protoc_insertion_point(field_get:common.topology.Switch.openflow_version)
  return openflow_version_;
}
inline void Switch::set_openflow_version(::google::protobuf::uint32 value) {
  set_has_openflow_version();
  openflow_version_ = value;
  // @@protoc_insertion_point(field_set:common.topology.Switch.openflow_version)
}

// repeated .common.topology.SwitchPort switch_ports = 3;
inline int Switch::switch_ports_size() const {
  return switch_ports_.size();
}
inline void Switch::clear_switch_ports() {
  switch_ports_.Clear();
}
inline const ::common::topology::SwitchPort& Switch::switch_ports(int index) const {
  // @@protoc_insertion_point(field_get:common.topology.Switch.switch_ports)
  return switch_ports_.Get(index);
}
inline ::common::topology::SwitchPort* Switch::mutable_switch_ports(int index) {
  // @@protoc_insertion_point(field_mutable:common.topology.Switch.switch_ports)
  return switch_ports_.Mutable(index);
}
inline ::common::topology::SwitchPort* Switch::add_switch_ports() {
  // @@protoc_insertion_point(field_add:common.topology.Switch.switch_ports)
  return switch_ports_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::common::topology::SwitchPort >&
Switch::switch_ports() const {
  // @@protoc_insertion_point(field_list:common.topology.Switch.switch_ports)
  return switch_ports_;
}
inline ::google::protobuf::RepeatedPtrField< ::common::topology::SwitchPort >*
Switch::mutable_switch_ports() {
  // @@protoc_insertion_point(field_mutable_list:common.topology.Switch.switch_ports)
  return &switch_ports_;
}

// optional .common.topology.SwitchSpecs switch_specs = 4;
inline bool Switch::has_switch_specs() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Switch::set_has_switch_specs() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Switch::clear_has_switch_specs() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Switch::clear_switch_specs() {
  if (switch_specs_ != NULL) switch_specs_->::common::topology::SwitchSpecs::Clear();
  clear_has_switch_specs();
}
inline const ::common::topology::SwitchSpecs& Switch::switch_specs() const {
  // @@protoc_insertion_point(field_get:common.topology.Switch.switch_specs)
  return switch_specs_ != NULL ? *switch_specs_ : *default_instance_->switch_specs_;
}
inline ::common::topology::SwitchSpecs* Switch::mutable_switch_specs() {
  set_has_switch_specs();
  if (switch_specs_ == NULL) switch_specs_ = new ::common::topology::SwitchSpecs;
  // @@protoc_insertion_point(field_mutable:common.topology.Switch.switch_specs)
  return switch_specs_;
}
inline ::common::topology::SwitchSpecs* Switch::release_switch_specs() {
  clear_has_switch_specs();
  ::common::topology::SwitchSpecs* temp = switch_specs_;
  switch_specs_ = NULL;
  return temp;
}
inline void Switch::set_allocated_switch_specs(::common::topology::SwitchSpecs* switch_specs) {
  delete switch_specs_;
  switch_specs_ = switch_specs;
  if (switch_specs) {
    set_has_switch_specs();
  } else {
    clear_has_switch_specs();
  }
  // @@protoc_insertion_point(field_set_allocated:common.topology.Switch.switch_specs)
}

// -------------------------------------------------------------------

// Topology

// repeated .common.topology.Switch switches = 1;
inline int Topology::switches_size() const {
  return switches_.size();
}
inline void Topology::clear_switches() {
  switches_.Clear();
}
inline const ::common::topology::Switch& Topology::switches(int index) const {
  // @@protoc_insertion_point(field_get:common.topology.Topology.switches)
  return switches_.Get(index);
}
inline ::common::topology::Switch* Topology::mutable_switches(int index) {
  // @@protoc_insertion_point(field_mutable:common.topology.Topology.switches)
  return switches_.Mutable(index);
}
inline ::common::topology::Switch* Topology::add_switches() {
  // @@protoc_insertion_point(field_add:common.topology.Topology.switches)
  return switches_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::common::topology::Switch >&
Topology::switches() const {
  // @@protoc_insertion_point(field_list:common.topology.Topology.switches)
  return switches_;
}
inline ::google::protobuf::RepeatedPtrField< ::common::topology::Switch >*
Topology::mutable_switches() {
  // @@protoc_insertion_point(field_mutable_list:common.topology.Topology.switches)
  return &switches_;
}

// repeated .common.topology.SwitchToSwitchLink switch_to_switch_links = 2;
inline int Topology::switch_to_switch_links_size() const {
  return switch_to_switch_links_.size();
}
inline void Topology::clear_switch_to_switch_links() {
  switch_to_switch_links_.Clear();
}
inline const ::common::topology::SwitchToSwitchLink& Topology::switch_to_switch_links(int index) const {
  // @@protoc_insertion_point(field_get:common.topology.Topology.switch_to_switch_links)
  return switch_to_switch_links_.Get(index);
}
inline ::common::topology::SwitchToSwitchLink* Topology::mutable_switch_to_switch_links(int index) {
  // @@protoc_insertion_point(field_mutable:common.topology.Topology.switch_to_switch_links)
  return switch_to_switch_links_.Mutable(index);
}
inline ::common::topology::SwitchToSwitchLink* Topology::add_switch_to_switch_links() {
  // @@protoc_insertion_point(field_add:common.topology.Topology.switch_to_switch_links)
  return switch_to_switch_links_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::common::topology::SwitchToSwitchLink >&
Topology::switch_to_switch_links() const {
  // @@protoc_insertion_point(field_list:common.topology.Topology.switch_to_switch_links)
  return switch_to_switch_links_;
}
inline ::google::protobuf::RepeatedPtrField< ::common::topology::SwitchToSwitchLink >*
Topology::mutable_switch_to_switch_links() {
  // @@protoc_insertion_point(field_mutable_list:common.topology.Topology.switch_to_switch_links)
  return &switch_to_switch_links_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace topology
}  // namespace common

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CommonTopology_2eproto__INCLUDED
