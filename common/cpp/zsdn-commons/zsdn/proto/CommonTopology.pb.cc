// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CommonTopology.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "CommonTopology.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace common {
namespace topology {

namespace {

const ::google::protobuf::Descriptor* AttachmentPoint_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AttachmentPoint_reflection_ = NULL;
const ::google::protobuf::Descriptor* PortSpecs_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PortSpecs_reflection_ = NULL;
const ::google::protobuf::Descriptor* Device_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Device_reflection_ = NULL;
const ::google::protobuf::Descriptor* SwitchPort_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SwitchPort_reflection_ = NULL;
const ::google::protobuf::Descriptor* SwitchToSwitchLink_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SwitchToSwitchLink_reflection_ = NULL;
const ::google::protobuf::Descriptor* SwitchSpecs_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SwitchSpecs_reflection_ = NULL;
const ::google::protobuf::Descriptor* Switch_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Switch_reflection_ = NULL;
const ::google::protobuf::Descriptor* Topology_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Topology_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_CommonTopology_2eproto() {
  protobuf_AddDesc_CommonTopology_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "CommonTopology.proto");
  GOOGLE_CHECK(file != NULL);
  AttachmentPoint_descriptor_ = file->message_type(0);
  static const int AttachmentPoint_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AttachmentPoint, switch_dpid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AttachmentPoint, switch_port_),
  };
  AttachmentPoint_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AttachmentPoint_descriptor_,
      AttachmentPoint::default_instance_,
      AttachmentPoint_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AttachmentPoint, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AttachmentPoint, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AttachmentPoint));
  PortSpecs_descriptor_ = file->message_type(1);
  static const int PortSpecs_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortSpecs, mac_address_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortSpecs, port_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortSpecs, config_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortSpecs, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortSpecs, curr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortSpecs, advertised_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortSpecs, supported_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortSpecs, peer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortSpecs, curr_speed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortSpecs, max_speed_),
  };
  PortSpecs_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PortSpecs_descriptor_,
      PortSpecs::default_instance_,
      PortSpecs_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortSpecs, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortSpecs, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PortSpecs));
  Device_descriptor_ = file->message_type(2);
  static const int Device_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Device, mac_address_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Device, ipv4_address_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Device, ipv6_address_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Device, vlan_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Device, millis_since_last_seen_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Device, attachment_point_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Device, additional_attachment_points_),
  };
  Device_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Device_descriptor_,
      Device::default_instance_,
      Device_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Device, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Device, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Device));
  SwitchPort_descriptor_ = file->message_type(3);
  static const int SwitchPort_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SwitchPort, attachment_point_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SwitchPort, port_specs_),
  };
  SwitchPort_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SwitchPort_descriptor_,
      SwitchPort::default_instance_,
      SwitchPort_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SwitchPort, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SwitchPort, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SwitchPort));
  SwitchToSwitchLink_descriptor_ = file->message_type(4);
  static const int SwitchToSwitchLink_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SwitchToSwitchLink, source_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SwitchToSwitchLink, target_),
  };
  SwitchToSwitchLink_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SwitchToSwitchLink_descriptor_,
      SwitchToSwitchLink::default_instance_,
      SwitchToSwitchLink_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SwitchToSwitchLink, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SwitchToSwitchLink, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SwitchToSwitchLink));
  SwitchSpecs_descriptor_ = file->message_type(5);
  static const int SwitchSpecs_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SwitchSpecs, n_buffers_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SwitchSpecs, n_tables_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SwitchSpecs, auxiliary_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SwitchSpecs, capabilities_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SwitchSpecs, reserved_),
  };
  SwitchSpecs_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SwitchSpecs_descriptor_,
      SwitchSpecs::default_instance_,
      SwitchSpecs_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SwitchSpecs, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SwitchSpecs, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SwitchSpecs));
  Switch_descriptor_ = file->message_type(6);
  static const int Switch_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Switch, switch_dpid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Switch, openflow_version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Switch, switch_ports_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Switch, switch_specs_),
  };
  Switch_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Switch_descriptor_,
      Switch::default_instance_,
      Switch_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Switch, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Switch, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Switch));
  Topology_descriptor_ = file->message_type(7);
  static const int Topology_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Topology, switches_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Topology, switch_to_switch_links_),
  };
  Topology_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Topology_descriptor_,
      Topology::default_instance_,
      Topology_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Topology, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Topology, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Topology));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_CommonTopology_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AttachmentPoint_descriptor_, &AttachmentPoint::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PortSpecs_descriptor_, &PortSpecs::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Device_descriptor_, &Device::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SwitchPort_descriptor_, &SwitchPort::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SwitchToSwitchLink_descriptor_, &SwitchToSwitchLink::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SwitchSpecs_descriptor_, &SwitchSpecs::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Switch_descriptor_, &Switch::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Topology_descriptor_, &Topology::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_CommonTopology_2eproto() {
  delete AttachmentPoint::default_instance_;
  delete AttachmentPoint_reflection_;
  delete PortSpecs::default_instance_;
  delete PortSpecs_reflection_;
  delete Device::default_instance_;
  delete Device_reflection_;
  delete SwitchPort::default_instance_;
  delete SwitchPort_reflection_;
  delete SwitchToSwitchLink::default_instance_;
  delete SwitchToSwitchLink_reflection_;
  delete SwitchSpecs::default_instance_;
  delete SwitchSpecs_reflection_;
  delete Switch::default_instance_;
  delete Switch_reflection_;
  delete Topology::default_instance_;
  delete Topology_reflection_;
}

void protobuf_AddDesc_CommonTopology_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\024CommonTopology.proto\022\017common.topology\""
    ";\n\017AttachmentPoint\022\023\n\013switch_dpid\030\001 \002(\004\022"
    "\023\n\013switch_port\030\002 \002(\r\"\274\001\n\tPortSpecs\022\023\n\013MA"
    "C_address\030\001 \001(\004\022\021\n\tport_name\030\002 \001(\t\022\016\n\006co"
    "nfig\030\003 \001(\r\022\r\n\005state\030\004 \001(\r\022\014\n\004curr\030\005 \001(\r\022"
    "\022\n\nadvertised\030\006 \001(\r\022\021\n\tsupported\030\007 \001(\r\022\014"
    "\n\004peer\030\010 \001(\r\022\022\n\ncurr_speed\030\t \001(\r\022\021\n\tmax_"
    "speed\030\n \001(\r\"\373\001\n\006Device\022\023\n\013MAC_address\030\001 "
    "\002(\004\022\024\n\014IPv4_address\030\002 \003(\r\022\024\n\014IPv6_addres"
    "s\030\003 \003(\014\022\014\n\004vlan\030\004 \001(\r\022\036\n\026millis_since_la"
    "st_seen\030\005 \002(\004\022:\n\020attachment_point\030\006 \002(\0132"
    " .common.topology.AttachmentPoint\022F\n\034add"
    "itional_attachment_points\030\007 \003(\0132 .common"
    ".topology.AttachmentPoint\"x\n\nSwitchPort\022"
    ":\n\020attachment_point\030\001 \002(\0132 .common.topol"
    "ogy.AttachmentPoint\022.\n\nport_specs\030\002 \001(\0132"
    "\032.common.topology.PortSpecs\"x\n\022SwitchToS"
    "witchLink\0220\n\006source\030\001 \002(\0132 .common.topol"
    "ogy.AttachmentPoint\0220\n\006target\030\002 \002(\0132 .co"
    "mmon.topology.AttachmentPoint\"p\n\013SwitchS"
    "pecs\022\021\n\tn_buffers\030\001 \001(\r\022\020\n\010n_tables\030\002 \001("
    "\r\022\024\n\014auxiliary_id\030\003 \001(\r\022\024\n\014capabilities\030"
    "\004 \001(\r\022\020\n\010reserved\030\005 \001(\r\"\236\001\n\006Switch\022\023\n\013sw"
    "itch_dpid\030\001 \002(\004\022\030\n\020openflow_version\030\002 \002("
    "\r\0221\n\014switch_ports\030\003 \003(\0132\033.common.topolog"
    "y.SwitchPort\0222\n\014switch_specs\030\004 \001(\0132\034.com"
    "mon.topology.SwitchSpecs\"z\n\010Topology\022)\n\010"
    "switches\030\001 \003(\0132\027.common.topology.Switch\022"
    "C\n\026switch_to_switch_links\030\002 \003(\0132#.common"
    ".topology.SwitchToSwitchLinkB#\n\rzsdn.pro"
    "tocolB\022ZsdnCommonProtocol", 1225);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "CommonTopology.proto", &protobuf_RegisterTypes);
  AttachmentPoint::default_instance_ = new AttachmentPoint();
  PortSpecs::default_instance_ = new PortSpecs();
  Device::default_instance_ = new Device();
  SwitchPort::default_instance_ = new SwitchPort();
  SwitchToSwitchLink::default_instance_ = new SwitchToSwitchLink();
  SwitchSpecs::default_instance_ = new SwitchSpecs();
  Switch::default_instance_ = new Switch();
  Topology::default_instance_ = new Topology();
  AttachmentPoint::default_instance_->InitAsDefaultInstance();
  PortSpecs::default_instance_->InitAsDefaultInstance();
  Device::default_instance_->InitAsDefaultInstance();
  SwitchPort::default_instance_->InitAsDefaultInstance();
  SwitchToSwitchLink::default_instance_->InitAsDefaultInstance();
  SwitchSpecs::default_instance_->InitAsDefaultInstance();
  Switch::default_instance_->InitAsDefaultInstance();
  Topology::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_CommonTopology_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_CommonTopology_2eproto {
  StaticDescriptorInitializer_CommonTopology_2eproto() {
    protobuf_AddDesc_CommonTopology_2eproto();
  }
} static_descriptor_initializer_CommonTopology_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int AttachmentPoint::kSwitchDpidFieldNumber;
const int AttachmentPoint::kSwitchPortFieldNumber;
#endif  // !_MSC_VER

AttachmentPoint::AttachmentPoint()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:common.topology.AttachmentPoint)
}

void AttachmentPoint::InitAsDefaultInstance() {
}

AttachmentPoint::AttachmentPoint(const AttachmentPoint& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:common.topology.AttachmentPoint)
}

void AttachmentPoint::SharedCtor() {
  _cached_size_ = 0;
  switch_dpid_ = GOOGLE_ULONGLONG(0);
  switch_port_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AttachmentPoint::~AttachmentPoint() {
  // @@protoc_insertion_point(destructor:common.topology.AttachmentPoint)
  SharedDtor();
}

void AttachmentPoint::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AttachmentPoint::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AttachmentPoint::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AttachmentPoint_descriptor_;
}

const AttachmentPoint& AttachmentPoint::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CommonTopology_2eproto();
  return *default_instance_;
}

AttachmentPoint* AttachmentPoint::default_instance_ = NULL;

AttachmentPoint* AttachmentPoint::New() const {
  return new AttachmentPoint;
}

void AttachmentPoint::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<AttachmentPoint*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(switch_dpid_, switch_port_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AttachmentPoint::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:common.topology.AttachmentPoint)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 switch_dpid = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &switch_dpid_)));
          set_has_switch_dpid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_switch_port;
        break;
      }

      // required uint32 switch_port = 2;
      case 2: {
        if (tag == 16) {
         parse_switch_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &switch_port_)));
          set_has_switch_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:common.topology.AttachmentPoint)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:common.topology.AttachmentPoint)
  return false;
#undef DO_
}

void AttachmentPoint::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:common.topology.AttachmentPoint)
  // required uint64 switch_dpid = 1;
  if (has_switch_dpid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->switch_dpid(), output);
  }

  // required uint32 switch_port = 2;
  if (has_switch_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->switch_port(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:common.topology.AttachmentPoint)
}

::google::protobuf::uint8* AttachmentPoint::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:common.topology.AttachmentPoint)
  // required uint64 switch_dpid = 1;
  if (has_switch_dpid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->switch_dpid(), target);
  }

  // required uint32 switch_port = 2;
  if (has_switch_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->switch_port(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:common.topology.AttachmentPoint)
  return target;
}

int AttachmentPoint::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 switch_dpid = 1;
    if (has_switch_dpid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->switch_dpid());
    }

    // required uint32 switch_port = 2;
    if (has_switch_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->switch_port());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AttachmentPoint::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AttachmentPoint* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AttachmentPoint*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AttachmentPoint::MergeFrom(const AttachmentPoint& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_switch_dpid()) {
      set_switch_dpid(from.switch_dpid());
    }
    if (from.has_switch_port()) {
      set_switch_port(from.switch_port());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AttachmentPoint::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AttachmentPoint::CopyFrom(const AttachmentPoint& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AttachmentPoint::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void AttachmentPoint::Swap(AttachmentPoint* other) {
  if (other != this) {
    std::swap(switch_dpid_, other->switch_dpid_);
    std::swap(switch_port_, other->switch_port_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AttachmentPoint::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AttachmentPoint_descriptor_;
  metadata.reflection = AttachmentPoint_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PortSpecs::kMACAddressFieldNumber;
const int PortSpecs::kPortNameFieldNumber;
const int PortSpecs::kConfigFieldNumber;
const int PortSpecs::kStateFieldNumber;
const int PortSpecs::kCurrFieldNumber;
const int PortSpecs::kAdvertisedFieldNumber;
const int PortSpecs::kSupportedFieldNumber;
const int PortSpecs::kPeerFieldNumber;
const int PortSpecs::kCurrSpeedFieldNumber;
const int PortSpecs::kMaxSpeedFieldNumber;
#endif  // !_MSC_VER

PortSpecs::PortSpecs()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:common.topology.PortSpecs)
}

void PortSpecs::InitAsDefaultInstance() {
}

PortSpecs::PortSpecs(const PortSpecs& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:common.topology.PortSpecs)
}

void PortSpecs::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  mac_address_ = GOOGLE_ULONGLONG(0);
  port_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  config_ = 0u;
  state_ = 0u;
  curr_ = 0u;
  advertised_ = 0u;
  supported_ = 0u;
  peer_ = 0u;
  curr_speed_ = 0u;
  max_speed_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PortSpecs::~PortSpecs() {
  // @@protoc_insertion_point(destructor:common.topology.PortSpecs)
  SharedDtor();
}

void PortSpecs::SharedDtor() {
  if (port_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete port_name_;
  }
  if (this != default_instance_) {
  }
}

void PortSpecs::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PortSpecs::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PortSpecs_descriptor_;
}

const PortSpecs& PortSpecs::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CommonTopology_2eproto();
  return *default_instance_;
}

PortSpecs* PortSpecs::default_instance_ = NULL;

PortSpecs* PortSpecs::New() const {
  return new PortSpecs;
}

void PortSpecs::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<PortSpecs*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(config_, peer_);
    mac_address_ = GOOGLE_ULONGLONG(0);
    if (has_port_name()) {
      if (port_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        port_name_->clear();
      }
    }
  }
  ZR_(curr_speed_, max_speed_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PortSpecs::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:common.topology.PortSpecs)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 MAC_address = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &mac_address_)));
          set_has_mac_address();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_port_name;
        break;
      }

      // optional string port_name = 2;
      case 2: {
        if (tag == 18) {
         parse_port_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_port_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->port_name().data(), this->port_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "port_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_config;
        break;
      }

      // optional uint32 config = 3;
      case 3: {
        if (tag == 24) {
         parse_config:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &config_)));
          set_has_config();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_state;
        break;
      }

      // optional uint32 state = 4;
      case 4: {
        if (tag == 32) {
         parse_state:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_curr;
        break;
      }

      // optional uint32 curr = 5;
      case 5: {
        if (tag == 40) {
         parse_curr:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &curr_)));
          set_has_curr();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_advertised;
        break;
      }

      // optional uint32 advertised = 6;
      case 6: {
        if (tag == 48) {
         parse_advertised:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &advertised_)));
          set_has_advertised();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_supported;
        break;
      }

      // optional uint32 supported = 7;
      case 7: {
        if (tag == 56) {
         parse_supported:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &supported_)));
          set_has_supported();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_peer;
        break;
      }

      // optional uint32 peer = 8;
      case 8: {
        if (tag == 64) {
         parse_peer:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &peer_)));
          set_has_peer();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_curr_speed;
        break;
      }

      // optional uint32 curr_speed = 9;
      case 9: {
        if (tag == 72) {
         parse_curr_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &curr_speed_)));
          set_has_curr_speed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_max_speed;
        break;
      }

      // optional uint32 max_speed = 10;
      case 10: {
        if (tag == 80) {
         parse_max_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_speed_)));
          set_has_max_speed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:common.topology.PortSpecs)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:common.topology.PortSpecs)
  return false;
#undef DO_
}

void PortSpecs::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:common.topology.PortSpecs)
  // optional uint64 MAC_address = 1;
  if (has_mac_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->mac_address(), output);
  }

  // optional string port_name = 2;
  if (has_port_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->port_name().data(), this->port_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "port_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->port_name(), output);
  }

  // optional uint32 config = 3;
  if (has_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->config(), output);
  }

  // optional uint32 state = 4;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->state(), output);
  }

  // optional uint32 curr = 5;
  if (has_curr()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->curr(), output);
  }

  // optional uint32 advertised = 6;
  if (has_advertised()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->advertised(), output);
  }

  // optional uint32 supported = 7;
  if (has_supported()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->supported(), output);
  }

  // optional uint32 peer = 8;
  if (has_peer()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->peer(), output);
  }

  // optional uint32 curr_speed = 9;
  if (has_curr_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->curr_speed(), output);
  }

  // optional uint32 max_speed = 10;
  if (has_max_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->max_speed(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:common.topology.PortSpecs)
}

::google::protobuf::uint8* PortSpecs::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:common.topology.PortSpecs)
  // optional uint64 MAC_address = 1;
  if (has_mac_address()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->mac_address(), target);
  }

  // optional string port_name = 2;
  if (has_port_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->port_name().data(), this->port_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "port_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->port_name(), target);
  }

  // optional uint32 config = 3;
  if (has_config()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->config(), target);
  }

  // optional uint32 state = 4;
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->state(), target);
  }

  // optional uint32 curr = 5;
  if (has_curr()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->curr(), target);
  }

  // optional uint32 advertised = 6;
  if (has_advertised()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->advertised(), target);
  }

  // optional uint32 supported = 7;
  if (has_supported()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->supported(), target);
  }

  // optional uint32 peer = 8;
  if (has_peer()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->peer(), target);
  }

  // optional uint32 curr_speed = 9;
  if (has_curr_speed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->curr_speed(), target);
  }

  // optional uint32 max_speed = 10;
  if (has_max_speed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->max_speed(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:common.topology.PortSpecs)
  return target;
}

int PortSpecs::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 MAC_address = 1;
    if (has_mac_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->mac_address());
    }

    // optional string port_name = 2;
    if (has_port_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->port_name());
    }

    // optional uint32 config = 3;
    if (has_config()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->config());
    }

    // optional uint32 state = 4;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->state());
    }

    // optional uint32 curr = 5;
    if (has_curr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->curr());
    }

    // optional uint32 advertised = 6;
    if (has_advertised()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->advertised());
    }

    // optional uint32 supported = 7;
    if (has_supported()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->supported());
    }

    // optional uint32 peer = 8;
    if (has_peer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->peer());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 curr_speed = 9;
    if (has_curr_speed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->curr_speed());
    }

    // optional uint32 max_speed = 10;
    if (has_max_speed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_speed());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PortSpecs::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PortSpecs* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PortSpecs*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PortSpecs::MergeFrom(const PortSpecs& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mac_address()) {
      set_mac_address(from.mac_address());
    }
    if (from.has_port_name()) {
      set_port_name(from.port_name());
    }
    if (from.has_config()) {
      set_config(from.config());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_curr()) {
      set_curr(from.curr());
    }
    if (from.has_advertised()) {
      set_advertised(from.advertised());
    }
    if (from.has_supported()) {
      set_supported(from.supported());
    }
    if (from.has_peer()) {
      set_peer(from.peer());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_curr_speed()) {
      set_curr_speed(from.curr_speed());
    }
    if (from.has_max_speed()) {
      set_max_speed(from.max_speed());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PortSpecs::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PortSpecs::CopyFrom(const PortSpecs& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PortSpecs::IsInitialized() const {

  return true;
}

void PortSpecs::Swap(PortSpecs* other) {
  if (other != this) {
    std::swap(mac_address_, other->mac_address_);
    std::swap(port_name_, other->port_name_);
    std::swap(config_, other->config_);
    std::swap(state_, other->state_);
    std::swap(curr_, other->curr_);
    std::swap(advertised_, other->advertised_);
    std::swap(supported_, other->supported_);
    std::swap(peer_, other->peer_);
    std::swap(curr_speed_, other->curr_speed_);
    std::swap(max_speed_, other->max_speed_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PortSpecs::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PortSpecs_descriptor_;
  metadata.reflection = PortSpecs_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Device::kMACAddressFieldNumber;
const int Device::kIPv4AddressFieldNumber;
const int Device::kIPv6AddressFieldNumber;
const int Device::kVlanFieldNumber;
const int Device::kMillisSinceLastSeenFieldNumber;
const int Device::kAttachmentPointFieldNumber;
const int Device::kAdditionalAttachmentPointsFieldNumber;
#endif  // !_MSC_VER

Device::Device()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:common.topology.Device)
}

void Device::InitAsDefaultInstance() {
  attachment_point_ = const_cast< ::common::topology::AttachmentPoint*>(&::common::topology::AttachmentPoint::default_instance());
}

Device::Device(const Device& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:common.topology.Device)
}

void Device::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  mac_address_ = GOOGLE_ULONGLONG(0);
  vlan_ = 0u;
  millis_since_last_seen_ = GOOGLE_ULONGLONG(0);
  attachment_point_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Device::~Device() {
  // @@protoc_insertion_point(destructor:common.topology.Device)
  SharedDtor();
}

void Device::SharedDtor() {
  if (this != default_instance_) {
    delete attachment_point_;
  }
}

void Device::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Device::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Device_descriptor_;
}

const Device& Device::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CommonTopology_2eproto();
  return *default_instance_;
}

Device* Device::default_instance_ = NULL;

Device* Device::New() const {
  return new Device;
}

void Device::Clear() {
  if (_has_bits_[0 / 32] & 57) {
    mac_address_ = GOOGLE_ULONGLONG(0);
    vlan_ = 0u;
    millis_since_last_seen_ = GOOGLE_ULONGLONG(0);
    if (has_attachment_point()) {
      if (attachment_point_ != NULL) attachment_point_->::common::topology::AttachmentPoint::Clear();
    }
  }
  ipv4_address_.Clear();
  ipv6_address_.Clear();
  additional_attachment_points_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Device::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:common.topology.Device)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 MAC_address = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &mac_address_)));
          set_has_mac_address();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_IPv4_address;
        break;
      }

      // repeated uint32 IPv4_address = 2;
      case 2: {
        if (tag == 16) {
         parse_IPv4_address:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_ipv4_address())));
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_ipv4_address())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_IPv4_address;
        if (input->ExpectTag(26)) goto parse_IPv6_address;
        break;
      }

      // repeated bytes IPv6_address = 3;
      case 3: {
        if (tag == 26) {
         parse_IPv6_address:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_ipv6_address()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_IPv6_address;
        if (input->ExpectTag(32)) goto parse_vlan;
        break;
      }

      // optional uint32 vlan = 4;
      case 4: {
        if (tag == 32) {
         parse_vlan:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &vlan_)));
          set_has_vlan();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_millis_since_last_seen;
        break;
      }

      // required uint64 millis_since_last_seen = 5;
      case 5: {
        if (tag == 40) {
         parse_millis_since_last_seen:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &millis_since_last_seen_)));
          set_has_millis_since_last_seen();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_attachment_point;
        break;
      }

      // required .common.topology.AttachmentPoint attachment_point = 6;
      case 6: {
        if (tag == 50) {
         parse_attachment_point:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_attachment_point()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_additional_attachment_points;
        break;
      }

      // repeated .common.topology.AttachmentPoint additional_attachment_points = 7;
      case 7: {
        if (tag == 58) {
         parse_additional_attachment_points:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_additional_attachment_points()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_additional_attachment_points;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:common.topology.Device)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:common.topology.Device)
  return false;
#undef DO_
}

void Device::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:common.topology.Device)
  // required uint64 MAC_address = 1;
  if (has_mac_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->mac_address(), output);
  }

  // repeated uint32 IPv4_address = 2;
  for (int i = 0; i < this->ipv4_address_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->ipv4_address(i), output);
  }

  // repeated bytes IPv6_address = 3;
  for (int i = 0; i < this->ipv6_address_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->ipv6_address(i), output);
  }

  // optional uint32 vlan = 4;
  if (has_vlan()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->vlan(), output);
  }

  // required uint64 millis_since_last_seen = 5;
  if (has_millis_since_last_seen()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->millis_since_last_seen(), output);
  }

  // required .common.topology.AttachmentPoint attachment_point = 6;
  if (has_attachment_point()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->attachment_point(), output);
  }

  // repeated .common.topology.AttachmentPoint additional_attachment_points = 7;
  for (int i = 0; i < this->additional_attachment_points_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->additional_attachment_points(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:common.topology.Device)
}

::google::protobuf::uint8* Device::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:common.topology.Device)
  // required uint64 MAC_address = 1;
  if (has_mac_address()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->mac_address(), target);
  }

  // repeated uint32 IPv4_address = 2;
  for (int i = 0; i < this->ipv4_address_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(2, this->ipv4_address(i), target);
  }

  // repeated bytes IPv6_address = 3;
  for (int i = 0; i < this->ipv6_address_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(3, this->ipv6_address(i), target);
  }

  // optional uint32 vlan = 4;
  if (has_vlan()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->vlan(), target);
  }

  // required uint64 millis_since_last_seen = 5;
  if (has_millis_since_last_seen()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->millis_since_last_seen(), target);
  }

  // required .common.topology.AttachmentPoint attachment_point = 6;
  if (has_attachment_point()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->attachment_point(), target);
  }

  // repeated .common.topology.AttachmentPoint additional_attachment_points = 7;
  for (int i = 0; i < this->additional_attachment_points_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->additional_attachment_points(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:common.topology.Device)
  return target;
}

int Device::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 MAC_address = 1;
    if (has_mac_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->mac_address());
    }

    // optional uint32 vlan = 4;
    if (has_vlan()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->vlan());
    }

    // required uint64 millis_since_last_seen = 5;
    if (has_millis_since_last_seen()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->millis_since_last_seen());
    }

    // required .common.topology.AttachmentPoint attachment_point = 6;
    if (has_attachment_point()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->attachment_point());
    }

  }
  // repeated uint32 IPv4_address = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->ipv4_address_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->ipv4_address(i));
    }
    total_size += 1 * this->ipv4_address_size() + data_size;
  }

  // repeated bytes IPv6_address = 3;
  total_size += 1 * this->ipv6_address_size();
  for (int i = 0; i < this->ipv6_address_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->ipv6_address(i));
  }

  // repeated .common.topology.AttachmentPoint additional_attachment_points = 7;
  total_size += 1 * this->additional_attachment_points_size();
  for (int i = 0; i < this->additional_attachment_points_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->additional_attachment_points(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Device::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Device* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Device*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Device::MergeFrom(const Device& from) {
  GOOGLE_CHECK_NE(&from, this);
  ipv4_address_.MergeFrom(from.ipv4_address_);
  ipv6_address_.MergeFrom(from.ipv6_address_);
  additional_attachment_points_.MergeFrom(from.additional_attachment_points_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mac_address()) {
      set_mac_address(from.mac_address());
    }
    if (from.has_vlan()) {
      set_vlan(from.vlan());
    }
    if (from.has_millis_since_last_seen()) {
      set_millis_since_last_seen(from.millis_since_last_seen());
    }
    if (from.has_attachment_point()) {
      mutable_attachment_point()->::common::topology::AttachmentPoint::MergeFrom(from.attachment_point());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Device::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Device::CopyFrom(const Device& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Device::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000031) != 0x00000031) return false;

  if (has_attachment_point()) {
    if (!this->attachment_point().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->additional_attachment_points())) return false;
  return true;
}

void Device::Swap(Device* other) {
  if (other != this) {
    std::swap(mac_address_, other->mac_address_);
    ipv4_address_.Swap(&other->ipv4_address_);
    ipv6_address_.Swap(&other->ipv6_address_);
    std::swap(vlan_, other->vlan_);
    std::swap(millis_since_last_seen_, other->millis_since_last_seen_);
    std::swap(attachment_point_, other->attachment_point_);
    additional_attachment_points_.Swap(&other->additional_attachment_points_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Device::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Device_descriptor_;
  metadata.reflection = Device_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SwitchPort::kAttachmentPointFieldNumber;
const int SwitchPort::kPortSpecsFieldNumber;
#endif  // !_MSC_VER

SwitchPort::SwitchPort()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:common.topology.SwitchPort)
}

void SwitchPort::InitAsDefaultInstance() {
  attachment_point_ = const_cast< ::common::topology::AttachmentPoint*>(&::common::topology::AttachmentPoint::default_instance());
  port_specs_ = const_cast< ::common::topology::PortSpecs*>(&::common::topology::PortSpecs::default_instance());
}

SwitchPort::SwitchPort(const SwitchPort& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:common.topology.SwitchPort)
}

void SwitchPort::SharedCtor() {
  _cached_size_ = 0;
  attachment_point_ = NULL;
  port_specs_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SwitchPort::~SwitchPort() {
  // @@protoc_insertion_point(destructor:common.topology.SwitchPort)
  SharedDtor();
}

void SwitchPort::SharedDtor() {
  if (this != default_instance_) {
    delete attachment_point_;
    delete port_specs_;
  }
}

void SwitchPort::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SwitchPort::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SwitchPort_descriptor_;
}

const SwitchPort& SwitchPort::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CommonTopology_2eproto();
  return *default_instance_;
}

SwitchPort* SwitchPort::default_instance_ = NULL;

SwitchPort* SwitchPort::New() const {
  return new SwitchPort;
}

void SwitchPort::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_attachment_point()) {
      if (attachment_point_ != NULL) attachment_point_->::common::topology::AttachmentPoint::Clear();
    }
    if (has_port_specs()) {
      if (port_specs_ != NULL) port_specs_->::common::topology::PortSpecs::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SwitchPort::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:common.topology.SwitchPort)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .common.topology.AttachmentPoint attachment_point = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_attachment_point()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_port_specs;
        break;
      }

      // optional .common.topology.PortSpecs port_specs = 2;
      case 2: {
        if (tag == 18) {
         parse_port_specs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_port_specs()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:common.topology.SwitchPort)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:common.topology.SwitchPort)
  return false;
#undef DO_
}

void SwitchPort::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:common.topology.SwitchPort)
  // required .common.topology.AttachmentPoint attachment_point = 1;
  if (has_attachment_point()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->attachment_point(), output);
  }

  // optional .common.topology.PortSpecs port_specs = 2;
  if (has_port_specs()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->port_specs(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:common.topology.SwitchPort)
}

::google::protobuf::uint8* SwitchPort::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:common.topology.SwitchPort)
  // required .common.topology.AttachmentPoint attachment_point = 1;
  if (has_attachment_point()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->attachment_point(), target);
  }

  // optional .common.topology.PortSpecs port_specs = 2;
  if (has_port_specs()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->port_specs(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:common.topology.SwitchPort)
  return target;
}

int SwitchPort::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .common.topology.AttachmentPoint attachment_point = 1;
    if (has_attachment_point()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->attachment_point());
    }

    // optional .common.topology.PortSpecs port_specs = 2;
    if (has_port_specs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->port_specs());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SwitchPort::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SwitchPort* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SwitchPort*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SwitchPort::MergeFrom(const SwitchPort& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_attachment_point()) {
      mutable_attachment_point()->::common::topology::AttachmentPoint::MergeFrom(from.attachment_point());
    }
    if (from.has_port_specs()) {
      mutable_port_specs()->::common::topology::PortSpecs::MergeFrom(from.port_specs());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SwitchPort::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SwitchPort::CopyFrom(const SwitchPort& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SwitchPort::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_attachment_point()) {
    if (!this->attachment_point().IsInitialized()) return false;
  }
  return true;
}

void SwitchPort::Swap(SwitchPort* other) {
  if (other != this) {
    std::swap(attachment_point_, other->attachment_point_);
    std::swap(port_specs_, other->port_specs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SwitchPort::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SwitchPort_descriptor_;
  metadata.reflection = SwitchPort_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SwitchToSwitchLink::kSourceFieldNumber;
const int SwitchToSwitchLink::kTargetFieldNumber;
#endif  // !_MSC_VER

SwitchToSwitchLink::SwitchToSwitchLink()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:common.topology.SwitchToSwitchLink)
}

void SwitchToSwitchLink::InitAsDefaultInstance() {
  source_ = const_cast< ::common::topology::AttachmentPoint*>(&::common::topology::AttachmentPoint::default_instance());
  target_ = const_cast< ::common::topology::AttachmentPoint*>(&::common::topology::AttachmentPoint::default_instance());
}

SwitchToSwitchLink::SwitchToSwitchLink(const SwitchToSwitchLink& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:common.topology.SwitchToSwitchLink)
}

void SwitchToSwitchLink::SharedCtor() {
  _cached_size_ = 0;
  source_ = NULL;
  target_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SwitchToSwitchLink::~SwitchToSwitchLink() {
  // @@protoc_insertion_point(destructor:common.topology.SwitchToSwitchLink)
  SharedDtor();
}

void SwitchToSwitchLink::SharedDtor() {
  if (this != default_instance_) {
    delete source_;
    delete target_;
  }
}

void SwitchToSwitchLink::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SwitchToSwitchLink::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SwitchToSwitchLink_descriptor_;
}

const SwitchToSwitchLink& SwitchToSwitchLink::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CommonTopology_2eproto();
  return *default_instance_;
}

SwitchToSwitchLink* SwitchToSwitchLink::default_instance_ = NULL;

SwitchToSwitchLink* SwitchToSwitchLink::New() const {
  return new SwitchToSwitchLink;
}

void SwitchToSwitchLink::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_source()) {
      if (source_ != NULL) source_->::common::topology::AttachmentPoint::Clear();
    }
    if (has_target()) {
      if (target_ != NULL) target_->::common::topology::AttachmentPoint::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SwitchToSwitchLink::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:common.topology.SwitchToSwitchLink)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .common.topology.AttachmentPoint source = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_target;
        break;
      }

      // required .common.topology.AttachmentPoint target = 2;
      case 2: {
        if (tag == 18) {
         parse_target:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_target()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:common.topology.SwitchToSwitchLink)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:common.topology.SwitchToSwitchLink)
  return false;
#undef DO_
}

void SwitchToSwitchLink::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:common.topology.SwitchToSwitchLink)
  // required .common.topology.AttachmentPoint source = 1;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->source(), output);
  }

  // required .common.topology.AttachmentPoint target = 2;
  if (has_target()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->target(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:common.topology.SwitchToSwitchLink)
}

::google::protobuf::uint8* SwitchToSwitchLink::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:common.topology.SwitchToSwitchLink)
  // required .common.topology.AttachmentPoint source = 1;
  if (has_source()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->source(), target);
  }

  // required .common.topology.AttachmentPoint target = 2;
  if (has_target()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->target(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:common.topology.SwitchToSwitchLink)
  return target;
}

int SwitchToSwitchLink::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .common.topology.AttachmentPoint source = 1;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->source());
    }

    // required .common.topology.AttachmentPoint target = 2;
    if (has_target()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->target());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SwitchToSwitchLink::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SwitchToSwitchLink* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SwitchToSwitchLink*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SwitchToSwitchLink::MergeFrom(const SwitchToSwitchLink& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_source()) {
      mutable_source()->::common::topology::AttachmentPoint::MergeFrom(from.source());
    }
    if (from.has_target()) {
      mutable_target()->::common::topology::AttachmentPoint::MergeFrom(from.target());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SwitchToSwitchLink::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SwitchToSwitchLink::CopyFrom(const SwitchToSwitchLink& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SwitchToSwitchLink::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_source()) {
    if (!this->source().IsInitialized()) return false;
  }
  if (has_target()) {
    if (!this->target().IsInitialized()) return false;
  }
  return true;
}

void SwitchToSwitchLink::Swap(SwitchToSwitchLink* other) {
  if (other != this) {
    std::swap(source_, other->source_);
    std::swap(target_, other->target_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SwitchToSwitchLink::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SwitchToSwitchLink_descriptor_;
  metadata.reflection = SwitchToSwitchLink_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SwitchSpecs::kNBuffersFieldNumber;
const int SwitchSpecs::kNTablesFieldNumber;
const int SwitchSpecs::kAuxiliaryIdFieldNumber;
const int SwitchSpecs::kCapabilitiesFieldNumber;
const int SwitchSpecs::kReservedFieldNumber;
#endif  // !_MSC_VER

SwitchSpecs::SwitchSpecs()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:common.topology.SwitchSpecs)
}

void SwitchSpecs::InitAsDefaultInstance() {
}

SwitchSpecs::SwitchSpecs(const SwitchSpecs& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:common.topology.SwitchSpecs)
}

void SwitchSpecs::SharedCtor() {
  _cached_size_ = 0;
  n_buffers_ = 0u;
  n_tables_ = 0u;
  auxiliary_id_ = 0u;
  capabilities_ = 0u;
  reserved_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SwitchSpecs::~SwitchSpecs() {
  // @@protoc_insertion_point(destructor:common.topology.SwitchSpecs)
  SharedDtor();
}

void SwitchSpecs::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SwitchSpecs::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SwitchSpecs::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SwitchSpecs_descriptor_;
}

const SwitchSpecs& SwitchSpecs::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CommonTopology_2eproto();
  return *default_instance_;
}

SwitchSpecs* SwitchSpecs::default_instance_ = NULL;

SwitchSpecs* SwitchSpecs::New() const {
  return new SwitchSpecs;
}

void SwitchSpecs::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<SwitchSpecs*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(n_buffers_, reserved_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SwitchSpecs::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:common.topology.SwitchSpecs)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 n_buffers = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &n_buffers_)));
          set_has_n_buffers();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_n_tables;
        break;
      }

      // optional uint32 n_tables = 2;
      case 2: {
        if (tag == 16) {
         parse_n_tables:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &n_tables_)));
          set_has_n_tables();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_auxiliary_id;
        break;
      }

      // optional uint32 auxiliary_id = 3;
      case 3: {
        if (tag == 24) {
         parse_auxiliary_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &auxiliary_id_)));
          set_has_auxiliary_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_capabilities;
        break;
      }

      // optional uint32 capabilities = 4;
      case 4: {
        if (tag == 32) {
         parse_capabilities:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &capabilities_)));
          set_has_capabilities();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_reserved;
        break;
      }

      // optional uint32 reserved = 5;
      case 5: {
        if (tag == 40) {
         parse_reserved:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &reserved_)));
          set_has_reserved();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:common.topology.SwitchSpecs)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:common.topology.SwitchSpecs)
  return false;
#undef DO_
}

void SwitchSpecs::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:common.topology.SwitchSpecs)
  // optional uint32 n_buffers = 1;
  if (has_n_buffers()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->n_buffers(), output);
  }

  // optional uint32 n_tables = 2;
  if (has_n_tables()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->n_tables(), output);
  }

  // optional uint32 auxiliary_id = 3;
  if (has_auxiliary_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->auxiliary_id(), output);
  }

  // optional uint32 capabilities = 4;
  if (has_capabilities()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->capabilities(), output);
  }

  // optional uint32 reserved = 5;
  if (has_reserved()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->reserved(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:common.topology.SwitchSpecs)
}

::google::protobuf::uint8* SwitchSpecs::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:common.topology.SwitchSpecs)
  // optional uint32 n_buffers = 1;
  if (has_n_buffers()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->n_buffers(), target);
  }

  // optional uint32 n_tables = 2;
  if (has_n_tables()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->n_tables(), target);
  }

  // optional uint32 auxiliary_id = 3;
  if (has_auxiliary_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->auxiliary_id(), target);
  }

  // optional uint32 capabilities = 4;
  if (has_capabilities()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->capabilities(), target);
  }

  // optional uint32 reserved = 5;
  if (has_reserved()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->reserved(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:common.topology.SwitchSpecs)
  return target;
}

int SwitchSpecs::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 n_buffers = 1;
    if (has_n_buffers()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->n_buffers());
    }

    // optional uint32 n_tables = 2;
    if (has_n_tables()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->n_tables());
    }

    // optional uint32 auxiliary_id = 3;
    if (has_auxiliary_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->auxiliary_id());
    }

    // optional uint32 capabilities = 4;
    if (has_capabilities()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->capabilities());
    }

    // optional uint32 reserved = 5;
    if (has_reserved()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->reserved());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SwitchSpecs::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SwitchSpecs* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SwitchSpecs*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SwitchSpecs::MergeFrom(const SwitchSpecs& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_n_buffers()) {
      set_n_buffers(from.n_buffers());
    }
    if (from.has_n_tables()) {
      set_n_tables(from.n_tables());
    }
    if (from.has_auxiliary_id()) {
      set_auxiliary_id(from.auxiliary_id());
    }
    if (from.has_capabilities()) {
      set_capabilities(from.capabilities());
    }
    if (from.has_reserved()) {
      set_reserved(from.reserved());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SwitchSpecs::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SwitchSpecs::CopyFrom(const SwitchSpecs& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SwitchSpecs::IsInitialized() const {

  return true;
}

void SwitchSpecs::Swap(SwitchSpecs* other) {
  if (other != this) {
    std::swap(n_buffers_, other->n_buffers_);
    std::swap(n_tables_, other->n_tables_);
    std::swap(auxiliary_id_, other->auxiliary_id_);
    std::swap(capabilities_, other->capabilities_);
    std::swap(reserved_, other->reserved_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SwitchSpecs::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SwitchSpecs_descriptor_;
  metadata.reflection = SwitchSpecs_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Switch::kSwitchDpidFieldNumber;
const int Switch::kOpenflowVersionFieldNumber;
const int Switch::kSwitchPortsFieldNumber;
const int Switch::kSwitchSpecsFieldNumber;
#endif  // !_MSC_VER

Switch::Switch()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:common.topology.Switch)
}

void Switch::InitAsDefaultInstance() {
  switch_specs_ = const_cast< ::common::topology::SwitchSpecs*>(&::common::topology::SwitchSpecs::default_instance());
}

Switch::Switch(const Switch& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:common.topology.Switch)
}

void Switch::SharedCtor() {
  _cached_size_ = 0;
  switch_dpid_ = GOOGLE_ULONGLONG(0);
  openflow_version_ = 0u;
  switch_specs_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Switch::~Switch() {
  // @@protoc_insertion_point(destructor:common.topology.Switch)
  SharedDtor();
}

void Switch::SharedDtor() {
  if (this != default_instance_) {
    delete switch_specs_;
  }
}

void Switch::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Switch::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Switch_descriptor_;
}

const Switch& Switch::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CommonTopology_2eproto();
  return *default_instance_;
}

Switch* Switch::default_instance_ = NULL;

Switch* Switch::New() const {
  return new Switch;
}

void Switch::Clear() {
  if (_has_bits_[0 / 32] & 11) {
    switch_dpid_ = GOOGLE_ULONGLONG(0);
    openflow_version_ = 0u;
    if (has_switch_specs()) {
      if (switch_specs_ != NULL) switch_specs_->::common::topology::SwitchSpecs::Clear();
    }
  }
  switch_ports_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Switch::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:common.topology.Switch)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 switch_dpid = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &switch_dpid_)));
          set_has_switch_dpid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_openflow_version;
        break;
      }

      // required uint32 openflow_version = 2;
      case 2: {
        if (tag == 16) {
         parse_openflow_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &openflow_version_)));
          set_has_openflow_version();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_switch_ports;
        break;
      }

      // repeated .common.topology.SwitchPort switch_ports = 3;
      case 3: {
        if (tag == 26) {
         parse_switch_ports:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_switch_ports()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_switch_ports;
        if (input->ExpectTag(34)) goto parse_switch_specs;
        break;
      }

      // optional .common.topology.SwitchSpecs switch_specs = 4;
      case 4: {
        if (tag == 34) {
         parse_switch_specs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_switch_specs()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:common.topology.Switch)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:common.topology.Switch)
  return false;
#undef DO_
}

void Switch::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:common.topology.Switch)
  // required uint64 switch_dpid = 1;
  if (has_switch_dpid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->switch_dpid(), output);
  }

  // required uint32 openflow_version = 2;
  if (has_openflow_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->openflow_version(), output);
  }

  // repeated .common.topology.SwitchPort switch_ports = 3;
  for (int i = 0; i < this->switch_ports_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->switch_ports(i), output);
  }

  // optional .common.topology.SwitchSpecs switch_specs = 4;
  if (has_switch_specs()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->switch_specs(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:common.topology.Switch)
}

::google::protobuf::uint8* Switch::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:common.topology.Switch)
  // required uint64 switch_dpid = 1;
  if (has_switch_dpid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->switch_dpid(), target);
  }

  // required uint32 openflow_version = 2;
  if (has_openflow_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->openflow_version(), target);
  }

  // repeated .common.topology.SwitchPort switch_ports = 3;
  for (int i = 0; i < this->switch_ports_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->switch_ports(i), target);
  }

  // optional .common.topology.SwitchSpecs switch_specs = 4;
  if (has_switch_specs()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->switch_specs(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:common.topology.Switch)
  return target;
}

int Switch::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 switch_dpid = 1;
    if (has_switch_dpid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->switch_dpid());
    }

    // required uint32 openflow_version = 2;
    if (has_openflow_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->openflow_version());
    }

    // optional .common.topology.SwitchSpecs switch_specs = 4;
    if (has_switch_specs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->switch_specs());
    }

  }
  // repeated .common.topology.SwitchPort switch_ports = 3;
  total_size += 1 * this->switch_ports_size();
  for (int i = 0; i < this->switch_ports_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->switch_ports(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Switch::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Switch* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Switch*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Switch::MergeFrom(const Switch& from) {
  GOOGLE_CHECK_NE(&from, this);
  switch_ports_.MergeFrom(from.switch_ports_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_switch_dpid()) {
      set_switch_dpid(from.switch_dpid());
    }
    if (from.has_openflow_version()) {
      set_openflow_version(from.openflow_version());
    }
    if (from.has_switch_specs()) {
      mutable_switch_specs()->::common::topology::SwitchSpecs::MergeFrom(from.switch_specs());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Switch::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Switch::CopyFrom(const Switch& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Switch::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->switch_ports())) return false;
  return true;
}

void Switch::Swap(Switch* other) {
  if (other != this) {
    std::swap(switch_dpid_, other->switch_dpid_);
    std::swap(openflow_version_, other->openflow_version_);
    switch_ports_.Swap(&other->switch_ports_);
    std::swap(switch_specs_, other->switch_specs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Switch::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Switch_descriptor_;
  metadata.reflection = Switch_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Topology::kSwitchesFieldNumber;
const int Topology::kSwitchToSwitchLinksFieldNumber;
#endif  // !_MSC_VER

Topology::Topology()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:common.topology.Topology)
}

void Topology::InitAsDefaultInstance() {
}

Topology::Topology(const Topology& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:common.topology.Topology)
}

void Topology::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Topology::~Topology() {
  // @@protoc_insertion_point(destructor:common.topology.Topology)
  SharedDtor();
}

void Topology::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Topology::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Topology::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Topology_descriptor_;
}

const Topology& Topology::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CommonTopology_2eproto();
  return *default_instance_;
}

Topology* Topology::default_instance_ = NULL;

Topology* Topology::New() const {
  return new Topology;
}

void Topology::Clear() {
  switches_.Clear();
  switch_to_switch_links_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Topology::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:common.topology.Topology)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .common.topology.Switch switches = 1;
      case 1: {
        if (tag == 10) {
         parse_switches:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_switches()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_switches;
        if (input->ExpectTag(18)) goto parse_switch_to_switch_links;
        break;
      }

      // repeated .common.topology.SwitchToSwitchLink switch_to_switch_links = 2;
      case 2: {
        if (tag == 18) {
         parse_switch_to_switch_links:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_switch_to_switch_links()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_switch_to_switch_links;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:common.topology.Topology)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:common.topology.Topology)
  return false;
#undef DO_
}

void Topology::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:common.topology.Topology)
  // repeated .common.topology.Switch switches = 1;
  for (int i = 0; i < this->switches_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->switches(i), output);
  }

  // repeated .common.topology.SwitchToSwitchLink switch_to_switch_links = 2;
  for (int i = 0; i < this->switch_to_switch_links_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->switch_to_switch_links(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:common.topology.Topology)
}

::google::protobuf::uint8* Topology::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:common.topology.Topology)
  // repeated .common.topology.Switch switches = 1;
  for (int i = 0; i < this->switches_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->switches(i), target);
  }

  // repeated .common.topology.SwitchToSwitchLink switch_to_switch_links = 2;
  for (int i = 0; i < this->switch_to_switch_links_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->switch_to_switch_links(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:common.topology.Topology)
  return target;
}

int Topology::ByteSize() const {
  int total_size = 0;

  // repeated .common.topology.Switch switches = 1;
  total_size += 1 * this->switches_size();
  for (int i = 0; i < this->switches_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->switches(i));
  }

  // repeated .common.topology.SwitchToSwitchLink switch_to_switch_links = 2;
  total_size += 1 * this->switch_to_switch_links_size();
  for (int i = 0; i < this->switch_to_switch_links_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->switch_to_switch_links(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Topology::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Topology* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Topology*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Topology::MergeFrom(const Topology& from) {
  GOOGLE_CHECK_NE(&from, this);
  switches_.MergeFrom(from.switches_);
  switch_to_switch_links_.MergeFrom(from.switch_to_switch_links_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Topology::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Topology::CopyFrom(const Topology& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Topology::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->switches())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->switch_to_switch_links())) return false;
  return true;
}

void Topology::Swap(Topology* other) {
  if (other != this) {
    switches_.Swap(&other->switches_);
    switch_to_switch_links_.Swap(&other->switch_to_switch_links_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Topology::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Topology_descriptor_;
  metadata.reflection = Topology_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace topology
}  // namespace common

// @@protoc_insertion_point(global_scope)
